ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  srchwave589.kern.br.d.phc.kres.f  differs from 587 in solving for both aniso
c  and isotropic lateral variations 
c                                  srchwave587.kern.br.d.phc.kres.f   
c  differs from 586 by correcting for first order effect of lateral velocity changes
c  on the sensitivity kernels - does not recalculate shape of kernel, but multiples
c  sensitivity by local correction factor                                             c
c     586   differs from 584 -  does not use uniform average velocity to correct DC level
c      of starting velocity model  CJR 2/22/09
c                            DWF  08/14/09 10/01/09  11/19/09   12/5/09   3/11/10     c
c
c JBR 10/15/2021 - Added one line to correctly read in station names from the
c                  input file generated by the eikonal_to_TPW matlab script.
c                - Separate output files for velocity model, azimuthal anisotropy,
c                  station corrections, and attenuation
c                - Add ability to specify reference gamma and gamma damping rather
c                  that being hard-coded in
c                - Add ability to specify damping on station correction terms
c
c JBR 1/26/2022  - Damp second plane wave amplitude to zero (i.e., remove focusing/defocusing effects)
c                - Damp first plane wave angle to zero (i.e., force propagation along great circle)
c
c  Search "JBR" to find edits
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c  calculates fit after linearized inversion to test whether predicted improvement is 
c  actually achieved
c
c  replaces simulated annealing search for wave parameters with grid search
c  INCLUDES wave parameters in linearized inversion
c  Differs from 534 by replacing Gaussian interpolation with linear interpolation
c  Differs from 544 by generating grid internally
c  Differs from 554 by correcting predicted starting phase velocities on fine grid
c  internally (crustal grid)
c  Differs from 564 by using minimum curvature criterion (smoothness) to
c  minimize off-diagonal elements of a posteriori model covariance matrix (actually,
c  minimize off-diagonal components of GtG matrix

c
c  Uses xmin constraint on using node sensitivities
c
c  this differs from standard 134 by damping amplitude corrections more in first
c  five iterations 
c
c  Outer grid points damped same as interior

c
c  data: observed phases and amplitudes at each station for each event

c  134 means to invert 2-D isotropic phase velocity ,station site responses 
c  and anisotropy in each subregions, with starting values for node coefficients
c  read in based on a priori model. phc means phase corrections,only  
c  for stations which have erroneous instrument phase response. 
c  
c  kern means using sensitivity kern to calculate the amplitude and phase 
c  at each station. The sensitivity kernel is calculated in this program, using 
c  input about frequencies involved from windowing. With the 
c  sensitivity kernel data, we can know the sensitivity at each node by 
c  interpolating the sensitivity kernel. 

c  anisotropy affects scattering
c     

c  Use minimum length criterion. Does not smooth but penalizes changes, 
c  with larger variance on outer edges, so that edges can take up
c  residual junk without propagating effects into the interior
c  Use tarantola terms to damp solution,grid of node points 
c  to interpolate velocity, and two plane waves per event

c  Run with piped input file like srchwave134.phc < eqlister50.
c  eqlister50 is an example file listing earthquake event at period 50s.
c  
c  This version reads in non-uniform starting model


      parameter (maxnfreq=1, maxnsta=300, nparam = 4000,
     1           maxnobs = 25000, maxnodes = 2000, maxevnts = 400,
     1           maxnxints = 401, maxnyints = 401,ndeg = 81 )
      parameter (mxfreqkern = 200)
      real*4 dph(maxevnts,maxnsta)
      real*4 staph(maxevnts,maxnsta,maxnfreq)
      real*4 staamp(maxevnts,maxnsta,maxnfreq)
      real*4 freq(maxnfreq)
      real*4 g(maxnobs,nparam)
      real*4 stddevdata(maxevnts)
      real*4 gtd(nparam), stddev(nparam), covinv(nparam)
      real*4 stadist(maxevnts,maxnsta), staazi(maxevnts,maxnsta)
      real*4 ysta(maxevnts,maxnsta), xsta(maxevnts,maxnsta)
      real*4 streal(maxevnts,maxnsta,maxnfreq)
      real*4 stimag(maxevnts,maxnsta,maxnfreq)
      real*4 rloc(maxevnts,maxnsta), azloc(maxevnts,maxnsta)
      real*4 attnfac(maxnfreq), xmin(maxevnts,ndeg)
      real*4 amprms(maxevnts,maxnfreq)
      real*4 bazi(maxevnts,maxnsta), stadelt(maxevnts,maxnsta)
      real*4  d(maxnobs)
      real*4 beg(maxevnts,maxnsta)
      real*4 origmod(nparam),crrntmod(nparam)
      real*4 boxlat(4), boxlon(4),applat,applon
      real*4 nodelat(maxnodes),nodelon(maxnodes), nodevel(maxnodes)
      real*4 nodecos2(maxnodes), nodesin2(maxnodes)
      real*4 xbox(maxevnts,4),ybox(maxevnts,4)
      real*4 xnode(maxevnts,maxnodes),ynode(maxevnts,maxnodes)
      real*4 stalat(maxevnts,maxnsta),stalon(maxevnts,maxnsta)
      real*4 tazim, delta, tazimref, bazimnd(maxnodes)
      real*4 adistsq,wgttemp(maxnodes)
      real*4 wgtnode1(maxnsta,maxnodes,ndeg)
      real*4 ampwgtnode1(maxnsta,maxnodes,ndeg) 
      real*4 dtime(maxnsta),avslow(maxnsta)	
      real*4 dtime1(maxnsta),dtime2(maxnsta),avslow1(maxnsta),
     1       avslow2(maxnsta)
      real*4 appvel(maxnodes),vage(maxnodes)
      real*4 cos2node(maxnodes,ndeg),sin2node(maxnodes,ndeg)
      real*4 startamp1(maxevnts),startamp2(maxevnts),stazim1(maxevnts)
      real*4 stazim2(maxevnts),stphase1(maxevnts),stphase2(maxevnts)
      real*4 pv(6),p(7,6),smsft(7),pb(6),annlscl(6),ppb(6),pppb(6)
      real*4 phcor(50)                                            
      real*4 minstd, rmsphase(maxevnts),rmsamp(maxevnts)
      real*4 sortrms(maxevnts)
      real*4 rmsdata(maxevnts)
      real*4 damp1per(maxevnts,maxnsta), damp2per(maxevnts,maxnsta)
      real*4 dphase1(maxevnts,maxnsta),dphase2(maxevnts,maxnsta)
      real*4 phase1(maxevnts,maxnsta), phase2(maxevnts,maxnsta)
      real*4 phase(maxnsta,ndeg),dphase(maxnsta,ndeg),
     1       dampper(maxnsta,ndeg)
      real*4 unifvel,ampmult(maxnsta)
      real*4 dxnode,dynode,xbegkern,dxkern
      real*4 ybegkern,dykern
      real*4 residdiag(maxnodes) 
      real*4 subgtd(nparam),substddev(nparam), subcovinv(nparam)
      real*4 gchange(maxnobs)
      real*4 covar(maxnodes,maxnodes),vchange(maxnodes)
      
      real*4 b(maxnodes,maxnodes),btb(maxnodes,maxnodes)

           
      integer*4 nxkern,nykern	
      integer*4 nsta(maxevnts), iref(maxevnts),idnode(maxnodes)
      integer*4 nfreq,nstapts(maxnsta),indx(nparam),nstacor,nobs
      integer*4 istanum(maxevnts,maxnsta),istacor(maxnsta), 
     1          nnodes, nevents, ntyp1                                
      integer*4 idnum(maxevnts),ityp1sta(maxnsta)                               
      integer*4 nevntsta(maxnsta),istavar(maxnsta)  
      integer*4 jbox(maxevnts)
      
      double precision change(nparam), gtdcmm(nparam)
      double precision gtg(nparam,nparam),gtginv(nparam,nparam),ddd
      double precision savegtg(nparam,nparam),chmax
      double precision subgtg(nparam,nparam),subgtdcmm(nparam)
      double precision subgtginv(nparam,nparam)
      double precision subsavegtg(nparam,nparam)
      
      real*8 sensitivity(maxnxints,maxnyints)
      real*8 ampsens(maxnxints,maxnyints)
      real*4 amsens(maxnxints,maxnyints),phsens(maxnxints,maxnyints)
      real*4 kk,lamda
      real*4 amplitude(mxfreqkern), freqkern(mxfreqkern)
      
      
      character*2   nettemp
      character*4   statemp 
      character*90  foutput,fsummary,fvariance
c  JBR - begin edit
      character*90  outvel, outazi, outstacor, outalpha
c  JBR - end edit
      character*90  finvrsnodes, fftinput
      character*90  fmaxavamp,fvelarea,ftemp, fstalist
      character*90  fvelout,fvelnodes, startvel
      character*90  sensfn
      character*90  dirpath
      character*90 fresdiag
      character*90 fendvel
      
c      character*75  dummy1
c      character*100 foutput,fn(maxevnts,maxnsta),fsummary
c  ******* changes in this area from yun version
c      character*100 foutput,fsummary
      character*4 staname(maxnsta)
      character*97 fn(maxevnts,maxnsta)
      character*85  dummy, dummy1 

       common /residua/ sensitivity,ampsens,d,rloc,azloc,freq,
     1 xsta,dtime,avslow,streal,stimag,stddevdata,phcor, 
     1 xbox,ybox,ysta,dxkern,dykern,dxnode,dynode,
     1 unifvel,appvel,ampmult,gamma,
     1 xnode, ynode,wgtnode1,ampwgtnode1,xmin,
     1 phase,dphase,dampper,istavar,istanum,nxkern,nykern,
     1 ityp1sta,ntyp1,iref,nsta,iev,naddat,ifreq,nnodes                 

       common /msft/ bazi,cos2node,sin2node,crrntmod,
     1   startamp1,startamp2,stphase1,stphase2,stazim1,stazim2,
     2   nevents,idnode,ideg1,ideg2,nobs,i6,iarea
     
       common /gengrid/ nodelat,nodelon,boxlat,boxlon
       
       common /update2/ covar,vchange


      pi = 3.1415928
      convdeg = 3.1415928/180.
      circ = 6371.*3.1415928/180.
      twopi = 3.1415928*2.
  

c Corresponding ID for abnormal stations.                   
c ntyp1: number of stations need phase correction
        ntyp1 = 0                                                     
c        data (ityp1sta(ityp), ityp=1, 4 )/1,3,172,174/
        if (ntyp1.ne.0) then              
	ityp1sta(1) = 1
	ityp1sta(2) = 3
        ityp1sta(3) = 172
        ityp1sta(4) = 174
	endif


200         format(a75, i2)
201         format(a90, a2)
c202         format(a39, a3)
202         format(a85, a3)


c  read list of files and frequencies to be analyzed and files to output results
c  Usually will pipe in data from some file like eqlistper50. 

      read(*,*) nevents
      nobs = 0
      do iev = 1, nevents
        read(*,*) nsta(iev),idnum(iev)
        nobs = nobs+ 2*nsta(iev)
	do i = 1, nsta(iev)
        read(*,*) fn(iev,i)
	enddo
      enddo
      
      read(*,*) nfreq
      read(*,*) (freq(j), j= 1, nfreq)
      read(*,*) foutput
      read(*,*) fsummary
      read(*,*) finvrsnodes
      read(*,*) fftinput
      read(*,*) fvariance
      read(*,*) fmaxavamp      
      read(*,*) ftemp
      read(*,*) fvelnodes
      read(*,*) fstalist
      read(*,*) unifvel 
      read(*,*) iterlimit, dampvel,dampaniso, divfac,
     +   divfac_azi
      read(*,'(a)') sensfn
      read(*,*) fvelout
      read(*,*)  startvel
      read(*,*) fresdiag
      read(*,*) fendvel
c  JBR - start edit
      read(*,*) outvel
      read(*,*) outazi
      read(*,*) outstacor
      read(*,*) outalpha
      read(*,*) refgamma
      read(*,*) dampgamma
      read(*,*) dampstacor
c  JBR - end edit


c  unifvel is average velocity found from inverting data previously for a single velocity
c  parameter
c   iterlimit is maximum number of iterations to use
c  dampvel is a priori stddev for velocity terms, dampaniso for aniso coeff.

c  read data
      open(10, file = foutput)
      open(11, file = fsummary)
      open(12, file = fftinput)
      open(13, file = ftemp)
      open(14, file = "followit12c")
c      open(15, file = finvrsnodes)
      open(16, file = fvariance)
      open(18, file = fstalist)
      open(30, file = fvelout)
c      open(66, file = dirpath//sensfn)
      open(66, file = sensfn)
c      open(60, file = startvel)
      open(21, file = fresdiag)
c  JBR - start edit
      open(22, file = outvel)
      open(23, file = outazi)
      open(24, file = outstacor)
      open(25, file = outalpha)
c  JBR - end edit      
      
c  do following step to extract station name from filename,
c  count number of events at each station and assign a station number 
c
c  first, read in master list of stations    
      do ista = 1, maxnsta
        nevntsta(ista) = 0
	read(18,*) staname(ista)
      write(14,*) staname(ista)
	if (staname(ista).eq.'nope') then
	  mxnsta = ista -1
	  go to 1111
	endif
      enddo
1111  continue
     
      do iev = 1, nevents
        do ista = 1, nsta(iev)

	 write(13,'(a)') fn(iev,ista)
C          write(*,*) fn(iev,ista)
          rewind (13)
	  
c  ******** modify here depending on how you assign your station ID  **************
	  
	  read (13,202) dummy1, statemp
	  rewind (13)
C    JBR - begin edit
       statemp = fn(iev,ista)
C       write(*,*) statemp
C    JBR - end edit
	  istanum(iev,ista) = 0
	  do ista2 = 1, mxnsta
	     if (statemp.eq.staname(ista2)) then
	       istanum(iev,ista) = ista2
	       nevntsta(ista2) = nevntsta(ista2) +1
	     endif
	  enddo
	  if (istanum(iev,ista).eq.0) then
	    write(*,*) 'WARNING ', statemp,' not in station list'
	  endif
c          write (*,*) ista, istanum(iev,ista),statemp
        enddo
      enddo

c  count number of stations that have events and assign each station number a
c  variable number

      jstacnt = 0
      do ista = 1, mxnsta
        if (nevntsta(ista).gt.0) then
          jstacnt = jstacnt+1
          istavar(ista) = jstacnt
        endif
      enddo


c  read in location of velocity nodes, box for limits of tomography
c  position in decimal degrees 

c      read(15,*) dummy
c      read(15,*) nnodes
c      do i = 1,nnodes	
c        read(15,*) nodelat(i),nodelon(i)
c      enddo
c      do i = 1, 4
c      read(15, *) boxlat(i), boxlon(i)	
c      enddo
c      read(15, *) ncol
c      read(15, *) dxnode,dynode

      call genreggrid(finvrsnodes,nnodes,ncol,dxnd,dynd)
       dxnode = abs(dxnd)
       dynode = abs(dynd)  
      
c      do i = 1,nnodes	
c        write(*,*) i, nodelat(i),nodelon(i)
c      enddo
c      do i = 1, 4
c        write(*, *) boxlat(i), boxlon(i)	
c      enddo
c      write(*, *) ncol
c      write(*, *) dxnode,dynode

c     generate sensitivity kernel
c     first, read in spectral file of frequencies and relative amps involved in particular
c        window/period processing for this target frequency
	

	radius = 6371.
	 read(66,*) nxkern, xbegkern, dxkern
	 read(66,*) nykern,ybegkern, dykern
	 if ((nxkern.gt.maxnxints).or.(nykern.gt.maxnyints)) then
	   write (*,*) "Too many points in sensitivity kernel"
	 endif
	 read(66,*) nkernfreq
	 sumkernamp = 0.0
	 do ifreqkern = 1, nkernfreq
	   read(66,*) freqkern(ifreqkern), amplitude(ifreqkern)
	 enddo
c  add extra, interpolated frequencies	
         do ifreqkern = 1, nkernfreq-1
	  amplitude(ifreqkern+nkernfreq) = 0.5*(amplitude(ifreqkern) 
     1                           + amplitude(ifreqkern+1))
          freqkern(ifreqkern+nkernfreq) = 0.5*(freqkern(ifreqkern)
     1                           +freqkern(ifreqkern+1))
	 enddo
	 nkernfreq = 2*nkernfreq -1
 	 do ifreqkern = 1, nkernfreq
	   sumkernamp = sumkernamp + amplitude(ifreqkern)
	  enddo
	
	 do ifreqkern = 1,nkernfreq
	   amplitude(ifreqkern) = amplitude(ifreqkern)/sumkernamp
	 enddo	

          do ixkern = 1,nxkern
	  do iykern = 1,nykern
	    amsens(ixkern,iykern) = 0.0
	    phsens(ixkern,iykern) = 0.0
            sensitivity(ixkern,iykern) = 0.
                ampsens(ixkern,iykern) = 0.
	  enddo
	  enddo
		 
	do ifreqkern = 1, nkernfreq
	 period = 1.0/freqkern(ifreqkern)
	 lamda = unifvel*period
         kk = 2.0*pi/lamda*radius
  	 do ixkern = 1,nxkern
	     xkern = (ixkern-1)*dxkern + xbegkern
  	     delta1 = xkern
	   do iykern = 1,nykern
	     ykern = (iykern-1)*dykern + ybegkern
	     if(xkern.eq.0 .and. ykern.eq.0) then 
	       delta2 = sqrt(dxkern**2+dykern**2)
	     else
	       delta2 = sqrt(xkern**2+ykern**2)
	     endif
cc formula from Ying Zhou et al., 2004, GJI 3-D sensitivity kernels for surface-wave observables

       phsens(ixkern,iykern) = phsens(ixkern,iykern)   + 
     1  amplitude(ifreqkern)*(-2.)*kk**2.
     1                *sin(kk*(delta1+delta2)/radius+pi/4.)
     1                 /sqrt(8.*pi*kk*abs(sin(delta2/radius)))
     1                 * ((dxkern*dykern)/radius**2) 

	amsens(ixkern,iykern) = amsens(ixkern,iykern) +
     1  amplitude(ifreqkern)*(-2.)*kk**2.
     1                 *cos(kk*(delta1+delta2)/radius+pi/4.)
     1                 /sqrt(8.*pi*kk*abs(sin(delta2/radius)))
     1              * ((dxkern*dykern)/radius**2)
              
       	   enddo
	 enddo
	enddo	     
c  now take these raw sensitivity kernels and find net effect for node velocities using
c  linear interpolation between nodes, essentially convolving interpolater with raw kernels
        ixoff = dxnode/dxkern
	iyoff = dynode/dykern
	do ixkern = 1, nxkern
	  ixxbeg = ixkern - ixoff
	  ixxend = ixkern + ixoff
	  if (ixxbeg.lt.1) ixxbeg = 1
	  if (ixxend.gt.nxkern) ixxend = nxkern
	  xk = (ixkern-1)*dxkern + xbegkern  
	  do iykern = 1,nykern	
	    iyybeg = iykern - iyoff
	    iyyend = iykern + iyoff
	    if (iyybeg.lt.1) iyybeg = 1
	    if (iyyend.gt.nykern) iyyend = nykern
	    yk = (iykern-1)*dykern + ybegkern
	    wgtsum = 0.0
	    do ix = ixxbeg, ixxend
	      xkk = (ix-1)*dxkern + xbegkern
	      do iy = iyybeg,iyyend
	        ykk = (iy-1)*dykern + ybegkern
		wgtkern = (1.-abs(xk-xkk)/dxnode)*(1.-abs(yk-ykk)/dynode)
		sensitivity(ixkern,iykern) = sensitivity(ixkern,iykern) 
     1                            + phsens(ix,iy)*wgtkern
     		ampsens(ixkern,iykern) = ampsens(ixkern,iykern)
     1                            + amsens(ix,iy)*wgtkern
		wgtsum = wgtsum+wgtkern
	      enddo
	    enddo
	    sensitivity(ixkern,iykern) = sensitivity(ixkern,iykern)/wgtsum
	    ampsens(ixkern,iykern) = ampsens(ixkern,iykern)/wgtsum
c	write(14,*) xk,yk,sensitivity(ixkern,iykern),ampsens(ixkern,iykern),
c     1        phsens(ixkern,iykern),amsens(ixkern,iykern)
	  enddo
	enddo
c  renormalize sensitivity kernels
	sensnorm =  (dxnode*dynode)/(dxkern*dykern)
          do ixkern = 1,nxkern
	  do iykern = 1,nykern
	    sensitivity(ixkern,iykern)=sensitivity(ixkern,iykern)*sensnorm
	     ampsens(ixkern,iykern)= ampsens(ixkern,iykern)*sensnorm
	  enddo
	  enddo
	  write (*,*) 'done with sensitivity'

c assign velocities to each grid node apriori

         call assignstrt(startvel,nodevel,preunifvel,nnodes,
     1                           ncol,dxnode,dynode)

      do i = 1, nnodes
c  read in starting node velocities based on a priori crustal model
c  but modify velocities for offset between average a priori and 
c  observed average from uniform velocity inversion - lateral velocity
c  variations will be preserved, but reference velocity will be observed average

cc         nodevel(i)=unifvel

c        read(60,*) xx1,xx2, nodevel(i)
c
c  following line is where 586 differs from 584 - without this line, the second following
c  line would shift the DC level of the starting predicted phase velocity model to agree with  
c  average velocity inferred previously from a 1-D inversion
        unifvel = preunifvel
	nodevel(i) = nodevel(i) + unifvel - preunifvel
c	write(14,*) nodelat(i),nodelon(i),nodevel(i)
      enddo


c Can input gridnode file to solve anisotropy in different areas.
c	open(20, file='gridnode.aniso.id')
c	open(20, file='invnodesethp_area2_test_ridge.d')
c	read(20,*) iarea
c
c  In version 589, iarea = nnodes
        iarea = 1
c        iarea = nnodes
	do i=1, nnodes
c	 read(20,*)ix, xx, xx, idnode(i)  			
         idnode(i) = 1 
c        idnode(i) = i
	enddo     
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      
      write(10, *) foutput
      write(11, *) foutput
c  start input loop over events
      do iv = 1, nevents
        read(12,*) iev
        do ista = 1, nsta(iev)
          read(12,*) beg(iev,ista)
          read(12,*) stadist(iev,ista),staazi(iev,ista), bazi(iev,ista),
     1    stadelt(iev,ista), stalat(iev,ista), stalon(iev,ista)
          read(12,*) (staamp(iev,ista,ifreq),staph(iev,ista,ifreq),
     1                               ifreq=1,nfreq)
C          write(*,*) iev, ista, staamp(iev,ista,1), staph(iev,ista,1)
        enddo
      enddo
c  end of input loop over events

      write(10,*) nfreq, '  nfreq'
      
c  begin inversion loop over frequencies

      do ifreq = 1, nfreq
        write(10,*) freq(ifreq)
        write(11,*) freq(ifreq)
        write(14,*) freq(ifreq)
        write(*,*) freq(ifreq)
c  assume a priori data covariance = 0.2  Function of this constant value is
c  to make damping based on real estimates about the right size.
        do iev = 1, nevents
          stddevdata(iev) = 0.2
        enddo
c  set up model covariances or damping to be added to diagonal of gtg
c  variables are amplitudes, directions, initial phases for each event
c  followed by isotropic velocities, anisotropic velocities for each area
c  then amplitude correction factors, phase correction factors for anomalous 
c  stations and attenuation factor gamma
        npnoamp = 6*nevents + 1*nnodes+ 2*iarea 
        npp = npnoamp + jstacnt 
	np = npp+ntyp1 + 1                           
        kj = nnodes/ncol
        i6 = 6*nevents
c   ***************************************
c  WARNING - the previous is specific to grid of node points - specify iages
c   even if age zones not explicitly used in inversion - needed for 
c   later smoothing
        do ii = 1, np
	  change(ii) = 0.0
	enddo
        do iev = 1, nevents
          ip = (iev-1)*6

          covinv(1+ip) = 1./(0.10**2)
c JBR - begin edit
c          covinv(2+ip) = 1./(0.10**2)
          covinv(2+ip) = 1./(0.00010**2)
c JBR - end edit
c JBR - begin edit
c          covinv(3+ip) = 1./((3.*convdeg)**2)
          covinv(3+ip) = 1./((0.003*convdeg)**2)
c JBR - end edit
          covinv(4+ip) = 1./((3.*convdeg)**2)
          covinv(5+ip) = 1./(.05**2)
          covinv(6+ip) = 1./(.05**2)
c          covinv(1+ip) = 1./(0.0010**2)
c          covinv(2+ip) = 1./(0.0010**2)
c          covinv(3+ip) = 1./((.03*convdeg)**2)
c          covinv(4+ip) = 1./((.03*convdeg)**2)
c          covinv(5+ip) = 1./(.0005**2)
c          covinv(6+ip) = 1./(.0005**2)

c  make covinv damping much tighter for grid search than for simulated annealing so that linearized
c  step following grid search for wave parameters won't go far astray.  

        enddo

        do ii= 1, nnodes
          ip = i6 + ii
          origmod(ip) = nodevel(ii)
c          origmod(ip) = unifvel
          covinv(ip) = 1./(dampvel**2)
          crrntmod(ip) = origmod(ip)
        enddo

c anisotropy varies in different areas	
         do i =1, iarea
          ipp = i6 + nnodes + i
          ippp = ipp + iarea 
          origmod(ipp) = 0.0
          origmod(ippp) = 0.0
          covinv(ipp) = 1./(dampaniso**2)
          covinv(ippp) = 1./(dampaniso**2)
          crrntmod(ipp) = origmod(ipp)
          crrntmod(ippp) = origmod(ippp)
         enddo  

c  initialize station correction variables and attenuation factor
c  May become singular if don't constrain average multiplication factor
c  because can multiply all by same amount and will trade-off with 
c  amplitude factors perfectly - add data point with small standard 
c  deviation

        do ii = 1, jstacnt
          ampmult(ii) = 1.0
          ip = npnoamp+ii
          origmod(ip) = ampmult(ii)
          crrntmod(ip) = origmod(ip)
c JBR - begin edit
c         covinv(ip) = 1.0/(0.30**2)
C         covinv(ip) = 1.0/(0.10**2)
         covinv(ip) = 1.0/(dampstacor**2)    
c JBR - end edit      
        enddo

c  initialize phase corrections for different instruments
	if (ntyp1.ne.0) then             
        do ii=1, ntyp1       			        	      
          phcor(ii)=0.0                                               
          ip=npp + ii                                                 
          origmod(ip) = phcor(ii)                                     
          crrntmod(ip) = origmod(ip)                                  
          covinv(ip) = 1.0/(0.1**2)                                   
        enddo
	endif
c  initialize gamma factor for attenuation
c JBR - begin edit
        gamma = refgamma
        origmod(np) = gamma
        crrntmod(np) = origmod(np)
        covinv(np) = 1.0/(dampgamma**2)
C        gamma = 0.0
C        origmod(np) = gamma
C        crrntmod(np) = origmod(np)
C        covinv(np) = 1.0/(0.0002**2)
c JBR - end edit

c  increase the variance for edges for velocity 

        varfac2 = 1.
        do itp = 1,1
         ityp = nnodes*(itp-1)
c  right end 
         do ijk = i6+1,i6+kj
           jk = ijk+ityp
           covinv(jk) = covinv(jk)/varfac2
         enddo
c  left end
         do ijk = i6+nnodes-kj+1,i6+nnodes
           jk = ijk+ityp
           covinv(jk) = covinv(jk)/varfac2
         enddo
c  top
         do ijk = i6+kj+1,i6+nnodes-2*kj+1,kj
           jk = ijk+ityp
           covinv(jk) = covinv(jk)/varfac2
         enddo
c  bottom
         do ijk = i6+2*kj,i6+nnodes-kj,kj
           jk = ijk+ityp
           covinv(jk) = covinv(jk)/varfac2
         enddo
        enddo


c  Set up coordinate systems and normalize amplitude for each event.
C  Begin loop over events for coordinates
      do iev = 1, nevents
c  Find reference station that has largest amplitude for each event.  
c  At this station, interfering waves should be nearly in phase and 
c  amplitude = sum of amps of individual waves

c  Also find normalizing amplitude to equalize earthquakes of different
c  size, using rms amplitude (old version used largest amplitude)

        amplarge =0.0
        amprms(iev,ifreq) = 0.0
        iref(iev) = 1
        do ista = 1, nsta(iev)
              amprms(iev,ifreq) = amprms(iev,ifreq)
     1                            + staamp(iev,ista,ifreq)**2
            if (staamp(iev,ista,ifreq).gt.amplarge) then
              amplarge = staamp(iev,ista,ifreq)
              iref(iev) = ista
           endif
        enddo
c	write(*,*) iev,iref(iev)
        amprms(iev,ifreq) = sqrt(amprms(iev,ifreq)/nsta(iev))
c       write(17,*) iev, amplarge, amprms(iev,ifreq)

  
c  Use reference station for to set up local coordinate system
c  based on reference station at zero, zero.  Use distances to stations rather
c  than absolute coordinates as way of correcting for curving wavefront.  This
c  will tend to favor keeping azimuth at original azimuth along great circle.
c  + x direction is in direction of propagation along great circle path.
c  +y is 90 deg counterclockwise from x
c   staazi are measured clockwise from north
      xsta(iev,iref(iev))  = 0.0
      ysta(iev,iref(iev))  = 0.0
      rloc(iev,iref(iev))  = 0.0
      azloc(iev,iref(iev)) = 0.0

      do ista = 1, nsta(iev)
        if (ista.ne.iref(iev)) then
        xsta(iev,ista) = stadist(iev,ista) - stadist(iev,iref(iev))
        azidiff = staazi(iev,iref(iev)) - staazi(iev,ista)
        if (azidiff.gt.180.) azidiff = azidiff -360.
        if (azidiff.lt.-180.) azidiff = azidiff +360.
        ysta(iev,ista) = circ*sin(stadelt(iev,ista)*convdeg)*
     1                   azidiff
        rloc(iev,ista) = sqrt(xsta(iev,ista)*xsta(iev,ista) + 
     1                        ysta(iev,ista)*ysta(iev,ista))
        azloc(iev,ista) = atan2(ysta(iev,ista),xsta(iev,ista))
        endif
      enddo

c  calculate apparent pole position of earthquake for spherical earth
c  instead of real location so that coordinate system for nodes will agree
c  with that for stations 
      call gohead(stalat(iev,iref(iev)),stalon(iev,iref(iev)),
     1    stadelt(iev,iref(iev)),bazi(iev,iref(iev)),applat,applon)
      call disthead(applat,applon,stalat(iev,iref(iev)),
     1    stalon(iev,iref(iev)),delta,tazimref)
c  now calculate x,y of each node 
c  this approach seems to work pretty well - agrees within about 0.1% with
c  station calculations based on elliptical great circle distance in terms
c  of relative position
      appcirc = stadist(iev,iref(iev))/stadelt(iev,iref(iev))
      do inode = 1, nnodes
        call disthead(applat,applon,nodelat(inode),nodelon(inode)
     1                                       ,delta,tazim)
        call disthead(nodelat(inode),nodelon(inode),applat,applon
     1                                       ,delta,bazimnd(inode))
        xnode(iev,inode) = appcirc*delta - stadist(iev,iref(iev))
        azidiff = tazimref - tazim
        if (azidiff.gt.180.) azidiff = azidiff -360.
        if (azidiff.lt.-180.) azidiff = azidiff +360.
        ynode(iev,inode) = appcirc*sin(delta*convdeg)*azidiff
      enddo
c  similarly for outlines of region of interest
      do ibox = 1, 4
        call disthead(applat,applon,boxlat(ibox),boxlon(ibox)
     1                                       ,delta,tazim)
        xbox(iev,ibox) = appcirc*delta - stadist(iev,iref(iev))
        azidiff = tazimref - tazim
        if (azidiff.gt.180.) azidiff = azidiff -360.
        if (azidiff.lt.-180.) azidiff = azidiff +360.
        ybox(iev,ibox) = appcirc*sin(delta*convdeg)*azidiff
c      write(*,*) ibox, xbox(ibox),ybox(ibox),delta, tazim
      enddo
c  find closest corner along great circle path
      xboxmin = xbox(iev,1)
      jbox(iev) = 1
      do ibox = 2,4
        if (xbox(iev,ibox).lt.xboxmin) then
	  xboxmin = xbox(iev,ibox)
	  jbox(iev) = ibox
	endif
      enddo      

c  find the mininum intersection point with corner for each allowed
c  azimuthal deviation of the two plane waves
c  - do not switch corners with azimuths as this
c  may cause discontinuous changes in needed wave parameters
c xmin here is distance from reference station of wavefront along path of
c  plane waves coming in at different angles

        do 124 ideg = 1,ndeg
         azimt = ((ideg-1.) - (ndeg-1.)/2.)*convdeg
	 xmin(iev,ideg) = 
     1     xbox(iev,jbox(iev))*cos(azimt)
     1     + ybox(iev,jbox(iev))*sin(azimt) 

  124    enddo

              
c  generate real and imaginary components normalized by rms amplitude
c  and compared to phase at reference station
c  Phase shift relative to reference corrected for any difference in start time
                  
        do ista = 1, nsta(iev)

          dph(iev,ista) = staph(iev,ista,ifreq)-staph(iev,iref(iev),
     1      ifreq) + freq(ifreq)*(beg(iev,ista)-beg(iev,iref(iev)))
          streal(iev,ista,ifreq)=staamp(iev,ista,ifreq)
     1            *cos(dph(iev,ista)*twopi)/amprms(iev,ifreq)
          stimag(iev,ista,ifreq)=-staamp(iev,ista,ifreq)
     1            *sin(dph(iev,ista)*twopi)/amprms(iev,ifreq)


        enddo		
      enddo		

c  construct form of a priori smooothness criterion matrix for velocity 
c  parameters  (minimum curvature)

c  initialize
      do ismth = 1, nnodes
        do jsmth = 1, nnodes
	  b(ismth,jsmth) = 0.0
	  btb(ismth,jsmth) = 0.0
	enddo
      enddo
c  curvature terms in y-direction - but skip at edges where undefined
      do ismth = 1,ncol
        do jsmth = 2, kj-1
	  ism = (ismth-1)*kj + jsmth
	  b(ism,ism) = 2.0 +b(ism,ism)
	  b(ism,ism-1) = -1.0+ b(ism,ism-1)
	  b(ism,ism+1) = -1.0+ b(ism,ism+1)
	enddo
      enddo
c  curvature terms in x-direction
      do jsmth = 1, kj
        do ismth = 2, ncol-1
	  ism = (ismth-1)*kj + jsmth 
	  b(ism,ism) = 2.0 +b(ism,ism)
	  b(ism,ism-kj) = -1.0 + b(ism,ism-kj)
	  b(ism,ism+kj) = -1.0 + b(ism,ism+kj)
	enddo
      enddo
c  now construct BtransposeB	
        do j = 1, nnodes
          do jj = 1,j
            btb(jj,j) = 0.0
            do i = 1, nnodes
              btb(jj,j)= btb(jj,j) + b(i,jj)*b(i,j)
            enddo
            btb(j,jj) = btb(jj,j)
          enddo
        enddo
c      do ismth = 1, nnodes
c        do jsmth = 1, nnodes
c	  write(14,*) ismth,jsmth,b(ismth,jsmth),btb(ismth,jsmth)
c	enddo
c      enddo
      


c  *************************
c  iterate from here
c  *************************
        iter = 1
        icnt = 1

c  add one data point for constraint on amplitude multipliers that has to
c  equal number of station corrections 
	nobs = nobs + 1 
        dstacnt = jstacnt

100     continue

c  increase a priori variance for station amplitude corrections after 5
c  iterations

	if (icnt.gt.5) then
	  do ii = 1, jstacnt
            ip = npnoamp+ii
c JBR - begin edit
C            covinv(ip) = 1.0/(0.30**2)
            covinv(ip) = 1.0/((dampstacor*3)**2)
c JBR - end edit
          enddo	
        endif
        sumampcor = 0.0
        do ii = 1, jstacnt
          sumampcor = sumampcor + ampmult(ii)
        enddo
        d(nobs) = (dstacnt - sumampcor)/1.0e-4     
	write(*,*) iter, icnt
c  initialize g matrix
        do irow = 1, nobs
        do icol = 1, np
          g(irow,icol) = 0.0
        enddo
        enddo

        do ii = 1,jstacnt
          icol = npnoamp+ii
          g(nobs,icol) = 1.0/1.0e-4
        enddo 


c  begin loop over events for residuals and partial derivatives

        naddat = 0
 
       do iev = 1, nevents
        
c   calculate the sensitivity kernel for each possible angle between -40 to 40

        do 125 ideg = 1,ndeg
          azimt = ((ideg-1.) - (ndeg-1.)/2.)*convdeg
          cs2n = cos(2.0*(convdeg*bazi(iev,iref(iev))- azimt))
	  sn2n = sin(2.0*(convdeg*bazi(iev,iref(iev))- azimt))
	  cs1z = cos(azimt)
	  sn1z = sin(azimt)
          do ii = 1,nnodes
c don't really need arrays here in this version, but used throughout so retained
            cos2node(ii,ideg)=cs2n
            sin2node(ii,ideg)=sn2n
          enddo

c  calculate current apparent velocity at each node

        do ii = 1, nnodes
          iii  = ii+i6
          jjj  = i6+nnodes + idnode(ii)
	  jjjj = jjj + iarea
          appvel(ii) =       crrntmod(iii)
     1   + cos2node(ii,ideg)*crrntmod(jjj)
     1   + sin2node(ii,ideg)*crrntmod(jjjj)
        enddo



c  loop over stations, generating sensitivity kernels for each
        do 102 ista = 1, nsta(iev)

          do ii = 1, nnodes
	      wgtnode1(ista,ii,ideg) = 0.0
	    ampwgtnode1(ista,ii,ideg) = 0.0
          enddo

          xstatemp = 
     1      xsta(iev,ista)*cs1z
     1      + ysta(iev,ista)*sn1z               
     
          ystatemp = 
     1      -xsta(iev,ista)*sn1z
     1      + ysta(iev,ista)*cs1z     

          do ii = 1,nnodes

           xnodetemp = 
     1      xnode(iev,ii)*cs1z
     1      + ynode(iev,ii)*sn1z               
     
           ynodetemp = 
     1      -xnode(iev,ii)*sn1z
     1      + ynode(iev,ii)*cs1z     


           xstanode = xnodetemp - xstatemp
	   ystanode = ynodetemp - ystatemp

c  find nearest point in sensitivity kernel - kernels should have been
c  calculated with smoothing so that they represent sensitivity to nodal
c  coefficient rather than velocity at point  - could interpolate, but 
c this is sufficiently accurate if kernels on fine enough scale (i.e.,
c  dxkern << smoothing length
          if (xnodetemp.ge.xmin(iev,ideg)) then
          if (xstanode.ge.0.0) then
            ixindex = int( xstanode/dxkern +0.5) + (nxkern+1)/2
	  else
	    ixindex = int( xstanode/dxkern -0.5) + (nxkern+1)/2
	  endif
          if (ystanode.ge.0.0) then
            iyindex = int( ystanode/dykern +0.5) + (nykern+1)/2
	  else
	    iyindex = int( ystanode/dykern -0.5) + (nykern+1)/2
	  endif

          if(  ixindex .lt.1 .or. ixindex .gt. nxkern
     1    .or. iyindex .lt.1 .or. iyindex .gt. nykern) then 


C	    write(*,*) 'ixindex,iyindex,iev,ista,ideg', 
C     1            ixindex,iyindex,iev,ista,ideg
	     wgtnode1(ista,ii,ideg)    = 0.
	     ampwgtnode1(ista,ii,ideg) = 0.  

 	   else

             wgtnode1(ista,ii,ideg) = sensitivity(ixindex,iyindex)
             ampwgtnode1(ista,ii,ideg) =     ampsens(ixindex,iyindex)
           endif 
	   else 
	     wgtnode1(ista,ii,ideg)    = 0.
	     ampwgtnode1(ista,ii,ideg) = 0.  
           endif	   
          enddo


	 dphase(ista,ideg) = 0.
         dampper(ista,ideg) = 0.

c  corrections for second order effects of large velocity changes in version 587
c   old version commented out
          do inode = 1, nnodes
c          dphase(ista,ideg) = dphase(ista,ideg) 
c     1  + (1.0/twopi)*wgtnode1(ista,inode,ideg)
c     1           *(appvel(inode)-unifvel)/unifvel
          dphase(ista,ideg) = dphase(ista,ideg) 
     1  + (1.0/twopi)*wgtnode1(ista,inode,ideg)
     2           *(appvel(inode)-unifvel)/appvel(inode)
     3           /(appvel(inode)/unifvel)

          enddo


	  do inode =1, nnodes
          dampper(ista,ideg) = dampper(ista,ideg) 
     1  +ampwgtnode1(ista,inode,ideg)*
c     1   (appvel(inode)-unifvel)/unifvel
     2    (appvel(inode)-unifvel)/appvel(inode)
     3           /(appvel(inode)/unifvel)
          enddo

c  end loop over stations
 102 	  enddo
c  end loop over angles
 125     enddo
c         write(*,*) iev, dphase(5,5),dampper(5,5)
c  find best fitting wave parameters from grid search
         call search(pb)
c      write(*,*)iev,pb(3)/convdeg,pb(4)/convdeg,pb(1),pb(2),pb(5),pb(6)

c  use best model as event starting model for linearized inversion
          ip = (iev-1)*6
          startamp1(iev) = pb(1)
          startamp2(iev) = pb(2)
          stazim1(iev) = pb(3)
          stazim2(iev) = pb(4)
          stphase1(iev) = pb(5)
          stphase2(iev) = pb(6)
          origmod(1+ip) = startamp1(iev)
          origmod(2+ip) = startamp2(iev)
          origmod(3+ip) = stazim1(iev)
          origmod(4+ip) = stazim2(iev)
          origmod(5+ip) = stphase1(iev)
          origmod(6+ip) = stphase2(iev)
          crrntmod(1+ip) = startamp1(iev)
          crrntmod(2+ip) = startamp2(iev)
          crrntmod(3+ip) = stazim1(iev)
          crrntmod(4+ip) = stazim2(iev)
          crrntmod(5+ip) = stphase1(iev)
          crrntmod(6+ip) = stphase2(iev)


c  calculate partial derivatives for wave parameters
         ideg1 = int(stazim1(iev)/convdeg+(ndeg-1)/2+0.01) + 1
         ideg2 = int(stazim2(iev)/convdeg+(ndeg-1)/2+0.01) + 1

c  calculate effect of uniform velocity for first plane wave
       do 10 ista = 1, nsta(iev)
       xstatemp = 
     1   xsta(iev,ista)*cos(stazim1(iev))
     1 + ysta(iev,ista)*sin(stazim1(iev))               
     
c       ystatemp = 
c     1  -xsta(iev,ista)*sin(stazim1(iev))
c     1 + ysta(iev,ista)*cos(stazim1(iev))     

   	dtime1(ista) = (xstatemp-xmin(iev,ideg1))/unifvel

  10 	  enddo


c       calculate for second plane wave
  
        do 20 ista = 1, nsta(iev)
         
       xstatemp = 
     1   xsta(iev,ista)*cos(stazim2(iev))
     1 + ysta(iev,ista)*sin(stazim2(iev))               
     
c       ystatemp = 
c     1  -xsta(iev,ista)*sin(stazim2(iev))
c     1 + ysta(iev,ista)*cos(stazim2(iev))     

   	dtime2(ista) = (xstatemp-xmin(iev,ideg2))/unifvel

  20    enddo
   
c  convert time to phase and assign effects of lateral heterogeneities

        do ista = 1, nsta(iev)

	   phase1(iev,ista) = dtime1(ista)*freq(1)
	   phase2(iev,ista) = dtime2(ista)*freq(1)
	  dphase1(iev,ista) =   dphase(ista,ideg1)
	  dphase2(iev,ista) =   dphase(ista,ideg2)  
          damp1per(iev,ista) = dampper(ista,ideg1)
	  damp2per(iev,ista) = dampper(ista,ideg2) 
       enddo


c calculate the change of ph1,ph2, damp1,damp2 with respect to azimuth at the reference station 

	aziminc1 = 2.*convdeg
	aziminc2 = 2.*convdeg
	if ((stazim1(iev)+aziminc1).gt.40.*convdeg) then
	  aziminc1 = -aziminc1
	endif
        if ((stazim2(iev)+aziminc2).gt.40.*convdeg) then
	  aziminc2 = -aziminc2
	endif
	
c	stazim1(iev) = stazim1(iev) + aziminc1
c	stazim2(iev) = stazim2(iev) + aziminc2
c
c         ideg1 = int(stazim1(iev)/convdeg+(ndeg-1)/2+0.01) + 1
c         ideg2 = int(stazim2(iev)/convdeg+(ndeg-1)/2+0.01) + 1
	staziminc1 = stazim1(iev) + aziminc1
	staziminc2 = stazim2(iev) + aziminc2

         ideg1 = int(staziminc1/convdeg+(ndeg-1)/2+0.01) + 1
         ideg2 = int(staziminc2/convdeg+(ndeg-1)/2+0.01) + 1


        xstatemp = 
     1   xsta(iev,iref(iev))*cos(staziminc1)
     1 + ysta(iev,iref(iev))*sin(staziminc1)               
     
c       ystatemp = 
c     1  -xsta(iev,iref(iev))*sin(staziminc1)
c     1 + ysta(iev,iref(iev))*cos(staziminc1)     

   
c  calculate delay due to uniform velocity


       dtime1ref = (xstatemp-xmin(iev,ideg1))/unifvel


c       calculate for second plane wave

       xstatemp = 
     1   xsta(iev,iref(iev))*cos(staziminc2)
     1 + ysta(iev,iref(iev))*sin(staziminc2)               
     
c       ystatemp = 
c     1  -xsta(iev,iref(iev))*sin(staziminc2)
c     1 + ysta(iev,iref(iev))*cos(staziminc2)     
 		
        dtime2ref = (xstatemp-xmin(iev,ideg2))/unifvel

c    convert time to phase and assign effects of lateral heterogeneities

          phase1ref = dtime1ref*freq(1)
	  phase2ref = dtime2ref*freq(1)
          dphase1ref =   dphase(iref(iev),ideg1)
	  dphase2ref =   dphase(iref(iev),ideg2) 
          damp1perref = dampper(iref(iev),ideg1)
	  damp2perref = dampper(iref(iev),ideg2)

c          stazim1(iev) = stazim1(iev) -aziminc1
c	  stazim2(iev) = stazim2(iev) - aziminc2

ccccccccccccccccccccccccc end of for refrence station ccccccccccccccccccccccccc

        do ista = 1,nsta(iev)
	
c          stazim1(iev) = stazim1(iev) + aziminc1
c	  stazim2(iev) = stazim2(iev) + aziminc2
	
c         ideg1 = int(stazim1(iev)/convdeg+(ndeg-1)/2) + 1
c         ideg2 = int(stazim2(iev)/convdeg+(ndeg-1)/2) + 1	  

       xstatemp = 
     1   xsta(iev,ista)*cos(staziminc1)
     1 + ysta(iev,ista)*sin(staziminc1)               
     
c       ystatemp = 
c     1  -xsta(iev,ista)*sin(staziminc1)
c     1 + ysta(iev,ista)*cos(staziminc1)     


         dtime1temp = (xstatemp-xmin(iev,ideg1))/unifvel


c       calculate for second plane wave
      xstatemp = 
     1   xsta(iev,ista)*cos(staziminc2)
     1 + ysta(iev,ista)*sin(staziminc2)               
     
c       ystatemp = 
c     1  -xsta(iev,ista)*sin(staziminc2(iev))
c     1 + ysta(iev,ista)*cos(staziminc2(iev))     

	  dtime2temp = (xstatemp-xmin(iev,ideg2))/unifvel

          phase1temp = dtime1temp*freq(1)
	  phase2temp = dtime2temp*freq(1)
	  dphase1temp = dphase(ista,ideg1)
	  dphase2temp = dphase(ista,ideg2)
          damp1pertemp = dampper(ista,ideg1)
	  damp2pertemp = dampper(ista,ideg2) 
  
c	stazim1(iev) = stazim1(iev) - aziminc1
c	stazim2(iev) = stazim2(iev) - aziminc2

c  calculate partial differences with respect to azimuth by finite differences

          parph1azim = ( (phase1temp+dphase1temp)-
     1          (phase1(iev,ista)+dphase1(iev,ista)))/aziminc1
     1                 - ( (phase1ref+dphase1ref) -
     1          (phase1(iev,iref(iev))+dphase1(iev,iref(iev))))/aziminc1

          parph2azim = ( (phase2temp+dphase2temp)-
     1          (phase2(iev,ista)+dphase2(iev,ista)))/aziminc2
     1                 - ( (phase2ref+dphase2ref) -
     1          (phase2(iev,iref(iev))+dphase2(iev,iref(iev))))/aziminc2

          pardamp1azim = (damp1pertemp - damp1per(iev,ista))/aziminc1
	  pardamp2azim = (damp2pertemp - damp2per(iev,ista))/aziminc2

c #################################################################

         ideg1 = int(stazim1(iev)/convdeg+(ndeg-1)/2 +0.01) + 1
         ideg2 = int(stazim2(iev)/convdeg+(ndeg-1)/2 +0.01) + 1




c########## end of parph1azim,parph2azim,pardamp1azim,pardamp2azim######## 

c        write(*,*) phase1(iev,ista),phase2(iev,ista)
        prefase1 = ( (phase1(iev,ista)+dphase1(iev,ista))
     1  - (phase1(iev,iref(iev))+dphase1(iev,iref(iev))))
     1             + stphase1(iev)
        prefase2 = ( (phase2(iev,ista)+dphase2(iev,ista))
     1  - (phase2(iev,iref(iev))+dphase2(iev,iref(iev))))
     1             + stphase2(iev)

	  staamp1 = startamp1(iev)*(1.+damp1per(iev,ista))
	  staamp2 = startamp2(iev)*(1.+damp2per(iev,ista))

        parph1cor1=0.                                        
        parph2cor1=0.                                        
	 
         itypst2=0
	if (ntyp1.ne.0) then 
        do itypst=1, ntyp1                                    
         if (istanum(iev,ista).eq.ityp1sta(itypst)) then     
          prefase1=prefase1+phcor(itypst)                    
          prefase2=prefase2+phcor(itypst)                    
          parph1cor1=1.                                      
          parph2cor1=1.                                      
	  itypst2=itypst                                     
	 endif                                               
        enddo                                                
	endif

          cosph1 = cos(prefase1*twopi)
          cosph2 = cos(prefase2*twopi)
          sinph1 = sin(prefase1*twopi)
          sinph2 = sin(prefase2*twopi)
          
          prereal = staamp1*cosph1+staamp2*cosph2
c	  write(*,*) prereal  
	  preimag = -1.0*(staamp1*sinph1+ staamp2*sinph2)
c           write(*,*) ampmult(istavar(istanum(iev,ista)))
          prereal = prereal*ampmult(istavar(istanum(iev,ista)))
     1          *exp(-gamma*xsta(iev,ista))
c          write(*,*) prereal
          preimag = preimag*ampmult(istavar(istanum(iev,ista)))
     1              *exp(-gamma*xsta(iev,ista))




c  data vector and partial derivatives listed event by event with all
c  real data for first event followed by imaginary data, then onto next event
c  d contains misfit to starting model


          kreal = ista + naddat
          kimag = kreal + nsta(iev)
          d(kreal) = (streal(iev,ista,ifreq) - prereal)/stddevdata(iev)
          d(kimag) = (stimag(iev,ista,ifreq) - preimag)/stddevdata(iev)


c  partial derivatives for station amplitude correction factors and attenuation
          g(kreal,npnoamp+istavar(istanum(iev,ista))) = 
     1      prereal/ampmult(istavar(istanum(iev,ista)))/stddevdata(iev)

          g(kimag,npnoamp+istavar(istanum(iev,ista))) = 
     1      preimag/ampmult(istavar(istanum(iev,ista)))/stddevdata(iev)
          g(kreal,np) = - xsta(iev,ista)*prereal/stddevdata(iev)
          g(kimag,np) = - xsta(iev,ista)*preimag/stddevdata(iev)

          ampadj = ampmult(istavar(istanum(iev,ista)))
     1        *exp(-gamma*xsta(iev,ista))
	  atte1 = 1.
	  atte2 = 1.
c  partial derivatives for station phase correction  
        if (itypst2.gt.0) then                                      
          g(kreal,npp+itypst2) = parph1cor1*(-staamp1*sinph1*twopi                
     1            -staamp2*sinph2*twopi)/stddevdata(iev)*ampadj                     
          g(kimag,npp+itypst2) = parph1cor1*(-staamp1*cosph1*twopi                
     1             -staamp2*cosph2*twopi)/stddevdata(iev)*ampadj                     
	endif

          do ii = 1, nnodes

       parph1v = (1.0/twopi)*wgtnode1(ista,ii,ideg1)/unifvel
     1         - (1.0/twopi)*wgtnode1(iref(iev),ii,ideg1)/unifvel

       parph2v =  (1.0/twopi)*wgtnode1(ista,ii,ideg2)/unifvel
     1          - (1.0/twopi)*wgtnode1(iref(iev),ii,ideg2)/unifvel

       parph1cs = (1.0/twopi)*cos2node(ii,ideg1)*
     1                         wgtnode1(ista,ii,ideg1)/unifvel
     1          - (1.0/twopi)*cos2node(ii,ideg1)*
     1                         wgtnode1(iref(iev),ii,ideg1)/unifvel

       parph2cs = (1.0/twopi)*cos2node(ii,ideg2)*
     1                         wgtnode1(ista,ii,ideg2)/unifvel
     1          - (1.0/twopi)*cos2node(ii,ideg2)*
     1                         wgtnode1(iref(iev),ii,ideg2)/unifvel

       parph1sn = (1.0/twopi)*sin2node(ii,ideg1)*
     1                         wgtnode1(ista,ii,ideg1)/unifvel
     1          - (1.0/twopi)*sin2node(ii,ideg1)*
     1                         wgtnode1(iref(iev),ii,ideg1)/unifvel

       parph2sn = (1.0/twopi)*sin2node(ii,ideg2)*
     1                         wgtnode1(ista,ii,ideg2)/unifvel
     1          - (1.0/twopi)*sin2node(ii,ideg2)*
     1                         wgtnode1(iref(iev),ii,ideg2)/unifvel



       paramp1v = startamp1(iev)*ampwgtnode1(ista,ii,ideg1)/unifvel 
       paramp2v = startamp2(iev)*ampwgtnode1(ista,ii,ideg2)/unifvel


       paramp1cs  = startamp1(iev)*cos2node(ii,ideg1)*
     1                            ampwgtnode1(ista,ii,ideg1)/unifvel

       paramp2cs  = startamp2(iev)*cos2node(ii,ideg2)*
     1                            ampwgtnode1(ista,ii,ideg2)/unifvel

       paramp1sn  = startamp1(iev)*sin2node(ii,ideg1)*
     1                            ampwgtnode1(ista,ii,ideg1)/unifvel

       paramp2sn  = startamp2(iev)*sin2node(ii,ideg2)*
     1                            ampwgtnode1(ista,ii,ideg2)/unifvel


c  partial derivatives with respect to velocity, & cos2theta &sin2theta

	  jjjarea=i6 + nnodes + idnode(ii)
	  jjjjarea=jjjarea+iarea

        g(kreal,i6+ii)= (-startamp1(iev)*(1.0+damp1per(iev,ista))*
     1                    twopi*sinph1*parph1v*atte1
     1                   -startamp2(iev)*(1.0+damp2per(iev,ista))*
     1                     twopi*sinph2*parph2v*atte2
     3        + paramp1v*cosph1*atte1 + paramp2v*cosph2*atte2 ) 
     2                *ampadj/stddevdata(iev) 

        g(kimag,i6+ii)= (-startamp1(iev)*(1.0+damp1per(iev,ista))*
     1                  twopi*cosph1*parph1v*atte1
     1                 -startamp2(iev)*(1.0+damp2per(iev,ista))*
     1                          twopi*cosph2*parph2v*atte2
     3      - (paramp1v*sinph1*atte1  +  paramp2v*sinph2*atte2 ) )
     2                *ampadj/stddevdata(iev) 


        g(kreal,jjjarea)= (-startamp1(iev)*(1.0+damp1per(iev,ista))
     1           *twopi*sinph1*parph1cs*atte1
     1                     -startamp2(iev)*(1.0+damp2per(iev,ista))
     1           *twopi*sinph2*parph2cs*atte2
     3        + paramp1cs*cosph1*atte1 + paramp2cs*cosph2*atte2 )
     2                     *ampadj/stddevdata(iev)+g(kreal,jjjarea)

        g(kimag,jjjarea)= (-startamp1(iev)*(1.0+damp1per(iev,ista))
     1           *twopi*cosph1*parph1cs*atte1
     2                     -startamp2(iev)*(1.0+damp2per(iev,ista))
     3           *twopi*cosph2*parph2cs*atte2
     3      - (paramp1cs*sinph1*atte1  +  paramp2cs*sinph2*atte2 ))
     3                     *ampadj/stddevdata(iev)+g(kimag,jjjarea)

        g(kreal,jjjjarea)= (-startamp1(iev)*(1.0+damp1per(iev,ista))
     1           *twopi*sinph1*parph1sn*atte1
     1                      -startamp2(iev)*(1.0+damp2per(iev,ista))
     1           *twopi*sinph2*parph2sn*atte2
     3        + paramp1sn*cosph1*atte1 + paramp2sn*cosph2*atte2 )
     2                     *ampadj/stddevdata(iev)+g(kreal,jjjjarea)

        g(kimag,jjjjarea)= (-startamp1(iev)*(1.0+damp1per(iev,ista))
     1           *twopi*cosph1*parph1sn*atte1
     2                      -startamp2(iev)*(1.0+damp2per(iev,ista))
     2           *twopi*cosph2*parph2sn*atte2
     3      - (paramp1sn*sinph1*atte1  +  paramp2sn*sinph2*atte2 ) )
     3                     *ampadj/stddevdata(iev)+g(kimag,jjjjarea)


          enddo
c  partial derivatives in order are with respect to amplitudes,
c  azimuths, starting phases and  slowness
          ip = (iev-1)*6
        g(kreal,1+ip) = (1.0+damp1per(iev,ista))*cosph1*atte1
     1                     *ampadj/stddevdata(iev)

        g(kreal,2+ip) = (1.0+damp2per(iev,ista))*cosph2*atte2
     1                     *ampadj/stddevdata(iev)

        g(kreal,3+ip) = (-startamp1(iev)*(1.0+damp1per(iev,ista))*sinph1
     1                      *parph1azim*twopi
     1                  + startamp1(iev)*pardamp1azim*cosph1)*atte1
     1                      *ampadj/stddevdata(iev)

        g(kreal,4+ip) = (-startamp2(iev)*(1.0+damp2per(iev,ista))*sinph2
     1                      *parph2azim*twopi
     1                  + startamp2(iev)*pardamp2azim*cosph2)*atte2 
     1                     *ampadj/stddevdata(iev)

        g(kreal,5+ip) = -startamp1(iev)*(1.0+damp1per(iev,ista))*sinph1
     1                      *twopi*atte1
     1                     *ampadj/stddevdata(iev)

        g(kreal,6+ip) = -startamp2(iev)*(1.0+damp2per(iev,ista))*sinph2
     1                      *twopi*atte2
     1                      *ampadj/stddevdata(iev)

        g(kimag,1+ip) = -(1.0+damp1per(iev,ista))*sinph1*atte1
     1                      *ampadj/stddevdata(iev)

        g(kimag,2+ip) = -(1.0+damp2per(iev,ista))*sinph2*atte2
     1                      *ampadj/stddevdata(iev)

        g(kimag,3+ip) = -(startamp1(iev)*(1.0+damp1per(iev,ista))*cosph1
     1                      *parph1azim*twopi
     1                      + startamp1(iev)*pardamp1azim*sinph1)*atte1
     1                      *ampadj/stddevdata(iev)

        g(kimag,4+ip) = -(startamp2(iev)*(1.0+damp2per(iev,ista))*cosph2
     1                      *parph2azim*twopi
     1                      + startamp2(iev)*pardamp2azim*sinph2)*atte2
     1                      *ampadj/stddevdata(iev)

        g(kimag,5+ip) = -startamp1(iev)*(1.0+damp1per(iev,ista))*cosph1
     1                      *twopi*atte1
     1                     *ampadj/stddevdata(iev)

        g(kimag,6+ip) = -startamp2(iev)*(1.0+damp2per(iev,ista))*cosph2
     1                      *twopi*atte2
     1                      *ampadj/stddevdata(iev)
c  normalize by stddevdata
        enddo

          naddat = naddat + 2*nsta(iev)
        enddo

c  calculate misfit before inversion
	premisfit = 0.0
	do i = 1, nobs
	  premisfit = premisfit + d(i)*d(i)
	enddo
	premisrms = sqrt(premisfit/nobs)
	write (*,*) "premisrms ", premisrms

c        write(*,*) "end loop over events for partial derivatives"
      do i = 1,6
        do j = 1, np
      write(14,*) i,j,g(i,j)
        enddo
      enddo
c  Calculate gtg and gtd	
        do j = 1, np
          gtd(j) = 0.0
          do i = 1, nobs
            gtd(j) = gtd(j) + g(i,j)*d(i)
          enddo
c   add to gtd Tarantola term penalizing misfit to original starting model
c   but skip for wave parameters

          if (j.le.i6) gtdcmm(j) = gtd(j)       
          if (j.gt.i6) gtdcmm(j) = gtd(j) - 
     1                       covinv(j)*(crrntmod(j)-origmod(j))
c          gtdcmm(j) = gtd(j) - covinv(j)*(crrntmod(j)-origmod(j))
c  construct gtg  
          do jj = 1,j
            gtg(jj,j) = 0.0
            do i = 1, nobs
              gtg(jj,j)= gtg(jj,j) + g(i,jj)*g(i,j)
            enddo
            gtg(j,jj) = gtg(jj,j)
            savegtg(j,jj) = gtg(j,jj)
            savegtg(jj,j) = gtg(jj,j)
	    if ((j.gt.i6).and.(jj.gt.i6)) write(14,*) j,jj,gtg(j,j)
          enddo
c increase damping for wave parameters
          gtg(j,j) = gtg(j,j) + covinv(j)
        enddo
c  ******************************
c   add smoothness constraint (minimum curvature).  Find coefficient, smthco, 
c  that minimizes, in least squares sense, the off-diagonal terms of gtg,
c   which should lead to minimal off-diagonal terms of covariance matrix
c
        sumsmth2 = 0.0
	sumsmgg = 0.0
	do ismth = 2,nnodes
	  do jsmth = 1, ismth-1
	    sumsmth2 = sumsmth2 + btb(ismth,jsmth)**2
	    sumsmgg = sumsmgg + btb(ismth,jsmth)*
     1                        gtg(ismth+i6,jsmth+i6)
      write(14,*) ismth,jsmth,gtg(ismth+i6,jsmth+i6) 
          enddo
	enddo
c	smthco = -sumsmgg/sumsmth2
	smthco = -sumsmgg/(sumsmth2*divfac)
	write(*,*) 'smthco', smthco
	do ismth = 1,nnodes
	  do jsmth = 1,nnodes
	    gtg(ismth+i6,jsmth+i6)= gtg(ismth+i6,jsmth+i6) +
     1               btb(ismth,jsmth)*smthco
          enddo
	enddo
c  also add smoothness constraint to Tarantola term penalizing curvature in
c  solution
        do ismth = 1,nnodes
	  do jsmth = 1, nnodes
	    gtdcmm(ismth+i6) = gtdcmm(ismth+i6) - 
     1   smthco*btb(ismth,jsmth)*(crrntmod(jsmth+i6)-origmod(jsmth+i6))
          enddo
	enddo
	    
c  ******************************
c  Now add smoothness constraint (minimum curvature) for cos2theta terms.  
c  Find coefficient, smthco1, 
c  that minimizes, in least squares sense, the off-diagonal terms of gtg,
c   which should lead to minimal off-diagonal terms of covariance matrix
c
        sumsmth2 = 0.0
	sumsmgg = 0.0
	i6pnod = i6 + nnodes
	do ismth = 2,nnodes
	  do jsmth = 1, ismth-1
	    sumsmth2 = sumsmth2 + btb(ismth,jsmth)**2
	    sumsmgg = sumsmgg + btb(ismth,jsmth)*
     1                gtg(ismth+i6pnod,jsmth+i6pnod)
          enddo
	enddo
	smthco1 = -sumsmgg/(sumsmth2*divfac_azi)
	write(*,*) 'smthco1 ', smthco1
	do ismth = 1,nnodes
	  do jsmth = 1,nnodes
	   gtg(ismth+i6pnod,jsmth+i6pnod)= gtg(ismth+i6pnod,jsmth+i6pnod)
     1              + btb(ismth,jsmth)*smthco1
          enddo
	enddo
c  also add smoothness constraint to Tarantola term penalizing curvature in
c  solution
        do ismth = 1,nnodes
	  do jsmth = 1, nnodes
	    gtdcmm(ismth+i6pnod) = gtdcmm(ismth+i6pnod) - 
     1      smthco1*btb(ismth,jsmth)*
     2      (crrntmod(jsmth+i6pnod)-origmod(jsmth+i6pnod))
          enddo
	enddo
c  ******************************
c  Now add smoothness constraint (minimum curvature) for sin2theta terms.  
c  Find coefficient, smthco2, 
c  that minimizes, in least squares sense, the off-diagonal terms of gtg,
c   which should lead to minimal off-diagonal terms of covariance matrix
c
        sumsmth2 = 0.0
	sumsmgg = 0.0
	i6pnod = i6 + 2*nnodes
	do ismth = 2,nnodes
	  do jsmth = 1, ismth-1
	    sumsmth2 = sumsmth2 + btb(ismth,jsmth)**2
	    sumsmgg = sumsmgg + btb(ismth,jsmth)*
     1           gtg(ismth+i6pnod,jsmth+i6pnod)
          enddo
	enddo
	smthco2 = -sumsmgg/(sumsmth2*divfac_azi)
	write(*,*) 'smthco2 ', smthco2
	do ismth = 1,nnodes
	  do jsmth = 1,nnodes
	   gtg(ismth+i6pnod,jsmth+i6pnod)= gtg(ismth+i6pnod,jsmth+i6pnod)
     1             +  btb(ismth,jsmth)*smthco2
          enddo
	enddo
c  also add smoothness constraint to Tarantola term penalizing curvature in
c  solution
        do ismth = 1,nnodes
	  do jsmth = 1, nnodes
	    gtdcmm(ismth+i6pnod) = gtdcmm(ismth+i6pnod) - 
     1      smthco2*btb(ismth,jsmth)*
     2      (crrntmod(jsmth+i6pnod)-origmod(jsmth+i6pnod))
          enddo
	enddo
	    
	    

c  ***********************
c  now eliminate wave parameters from inversion process
c  too many parameters and too unstable when small number of observations
c  per event
c  *************************
c      npsub = np - i6
c	do j = 1, npsub
c	  do jj = 1, j
c	    subgtg(jj,j) = gtg(jj+i6,j+i6)
c	    subgtg(j,jj) = subgtg(jj,j)
c            subsavegtg(j,jj) = savegtg(j+i6,jj+i6) 
c            subsavegtg(jj,j) = savegtg(jj+i6,j+i6)
c	  enddo
c	  subgtd(j) = gtd(j+i6)
c	  subgtdcmm(j) = gtdcmm(j+i6)
c	enddo
   

c  Invert gtg.  gtg will be destroyed.  
C  Not the most efficient approach because doesn't take advantage of 
c  symmetry of gtg.  Use LU decomposition from Press et al.
        do i= 1,np
          do j = 1, np
            gtginv(i,j)= 0.0D0
          enddo
          gtginv(i,i) =1.0D0
        enddo
        call dludcmp(gtg,np,nparam,indx,ddd)
        do j = 1,np
          call dlubksb(gtg,np,nparam,indx,gtginv(1,j))
        enddo
c	do i= 1,npsub
c          do j = 1, npsub
c            subgtginv(i,j)= 0.0D0
c          enddo
c          subgtginv(i,i) =1.0D0
c        enddo
c        call dludcmp(subgtg,npsub,nparam,indx,ddd)
c        do j = 1,np
c          call dlubksb(subgtg,npsub,nparam,indx,subgtginv(1,j))
c        enddo

c  Find change to starting model
        do i= 1, np
          change(i)=0.0
          do j = 1,np
            change(i) =change(i) + gtdcmm(j)*gtginv(i,j)
          enddo
        enddo
c       do i= 1, npsub
c          change(i+i6)=0.0
c          do j = 1,npsub
c            change(i+i6) =change(i+i6) + subgtdcmm(j)*subgtginv(i,j)
c          enddo
c        enddo

c  Find rank (sum of diagonals of resolution matrix), i.e., number of
c  pieces of information or number of independent model parameters
c  rank1 is contribution from source wave terms, rank2 from velocity
c  variables
        rank1 = 0.0
        rank2 = 0.0
	rank3 = 0.0
	rank4 = 0.0
	write(14,*) icnt,iter
	do i=1,np
	  write(14,*) i, crrntmod(i),change(i)
          resparm =0.0
          do j = 1,np
            resparm = resparm + gtginv(i,j)*savegtg(j,i)
          enddo
          if (i.le.i6) then
            rank1 = rank1 + resparm
	  endif
          if ((i.gt.i6).and.(i.le.i6+nnodes)) then
            rank2 = rank2 + resparm
c   Remember diagonal resolution values for isotropic velocity parameters
	    residdiag(i-i6) = resparm
	  endif
          if ((i.gt.i6+nnodes).and.(i.le.npnoamp)) then
            rank4 = rank4 + resparm
          endif
	  if (i.gt.npnoamp) then
	    rank3 = rank3 + resparm
	  endif
        enddo 
        rank = rank1 + rank2 +rank3 + rank4   
c************************************
c	do i=1,npsub
c          resparm =0.0
c          do j = 1,npsub
c            resparm = resparm + subgtginv(i,j)*subsavegtg(j,i)
c          enddo
c          if (i.le.i6) then
c            rank1 = rank1 + resparm
c          else
c          if (i.le.(npnoamp-i6)) then
c            rank2 = rank2 + resparm
c	    if (i.le.nnodes) then
c	      residdiag(i) = resparm
c	    endif
c	   else
c	     rank3 = rank3 + resparm
c	   endif
	   
c          endif
c        enddo 
c        rank = rank2 + rank3     

c  Update current model

 
        naddat = 0
        do iev = 1,nevents
          ip = (iev-1)*6
          startamp1(iev) = startamp1(iev) + change(1+ip)
          startamp2(iev) = startamp2(iev) + change(2+ip)
          stazim1(iev) = stazim1(iev) + change(3+ip)
          stazim2(iev) = stazim2(iev) + change(4+ip)

c       if(stazim1(iev) .lt. -40.*convdeg) stazim1(iev) = -40.*convdeg
c       if(stazim1(iev) .gt. 40.*convdeg)  stazim1(iev) = 40.*convdeg
c       if(stazim2(iev) .lt. -40.*convdeg) stazim2(iev) = -40.*convdeg
c       if(stazim2(iev) .gt. 40.*convdeg)  stazim2(iev) = 40.*convdeg

          stphase1(iev) = stphase1(iev) + change(5+ip)
          stphase2(iev) = stphase2(iev) + change(6+ip)
          crrntmod(1+ip) = startamp1(iev)
          crrntmod(2+ip) = startamp2(iev)
          crrntmod(3+ip) = stazim1(iev)
          crrntmod(4+ip) = stazim2(iev)
          crrntmod(5+ip) = stphase1(iev)
          crrntmod(6+ip) = stphase2(iev)

        sumsq = 0.0
        sumsqph = 0.0

          do ista = 1,nsta(iev)
            dresid1=d(ista+naddat)*stddevdata(iev)
            dresid2=d(ista+naddat+nsta(iev))*stddevdata(iev)
            predamp = amprms(iev,ifreq)
     1        *sqrt((streal(iev,ista,ifreq)-dresid1)**2 
     2                + (stimag(iev,ista,ifreq)-dresid2)**2)
            prefase = atan2(-(stimag(iev,ista,ifreq)-dresid2),
     1                (streal(iev,ista,ifreq)-dresid1))/twopi
c check for prefase being off by multiple of twopi
           absmis = abs(prefase - dph(iev,ista))
	   phasemis = absmis - int(absmis)	   
           if (phasemis.gt.0.5) phasemis = phasemis-1.0

           sumsq = sumsq+(d(ista+naddat)**2+d(ista+naddat+nsta(iev))**2)
     1               *stddevdata(iev)**2
           sumsqph = sumsqph + (dph(iev,ista)-prefase)**2
          enddo

             rmsph = sqrt(sumsqph/nsta(iev))/freq(ifreq)
	     
              if ((2*nsta(iev) - rank2/nevents - 6).lt.1.0) then
c              if ((2*nsta(iev) - rank/nevents - 6).lt.1.0) then
	      sigma2=sqrt(sumsq/1.0)
	      else
	      sigma2 = sqrt(sumsq/(2*nsta(iev) - rank2/nevents - 6))
c	      sigma2 = sqrt(sumsq/(2*nsta(iev) - rank/nevents - 6))
	      endif



          naddat = naddat + 2*nsta(iev)

	write(10,*) 'iev', idnum(iev),'  sigma2 ',sigma2,  'rmsph ',rmsph
	write(10,*) stazim1(iev)/convdeg,startamp1(iev),stphase1(iev)
	write(10,*) stazim2(iev)/convdeg,startamp2(iev),stphase2(iev)

        enddo

c  update node coefficients and calculate average isotropic velocity
	avgvel = 0.0
        do ii = 1, nnodes
          crrntmod(ii+i6) = crrntmod(ii+i6) + change(ii+i6)
	  avgvel = avgvel + crrntmod(ii+i6)
        enddo
	avgvel = avgvel/nnodes
	write(*,*) "avgvel ",avgvel
        do ii = 1, iarea
          iii = ii+i6 + nnodes
          iiii = iii+iarea
          crrntmod(iii) = crrntmod(iii) + change(iii)
          crrntmod(iiii) = crrntmod(iiii) + change(iiii)
        enddo

        do ii = 1, jstacnt
          ip = ii + npnoamp
          ampmult(ii) = ampmult(ii) + change(ip)
          crrntmod(ip) = ampmult(ii)
        enddo

c      changed for no aniso
c        do ii = 1, iages
c          iii = ii+i6 + nnodes
c          iiii = iii+iages
c          crrntmod(iii) = crrntmod(iii) + change(iii)
c          crrntmod(iiii) = crrntmod(iiii) + change(iiii)
c        enddo

	if (ntyp1.ne.0) then
         do ii=1,ntyp1                                          
           ip=npp+ii                                            
           phcor(ii)=phcor(ii)+change(ip)                       
           crrntmod(ip)=phcor(ii)                               
           write(14,*)"phcor ",ii, ityp1sta(ii), phcor(ii)      
           write(*,*)"phcor ",ii, ityp1sta(ii), phcor(ii)      
        enddo                                                   
	endif
        gamma = gamma + change(np)
        crrntmod(np) = gamma
	
c  Calculate predicted effect of change in model parameters and compare to actual effect
        predmis = 0.0
        do ic = 1, nobs
	  gchange(ic) = 0.0
	  do jc = i6+1,np
	    gchange(ic) = gchange(ic) + g(ic,jc)*change(jc)
	  enddo
	  predmis = predmis + (d(ic)-gchange(ic))**2
	enddo
	predmisrms = sqrt(predmis/nobs)
	write (*,*) "predmisrms ",predmisrms
c	call actlmsft(actmisrms)
c  subroutine setup for integer values of azimuths only - don't call - just for debugging
c   anyway to check for non-linearity		
c	write(*,*) "predmisrms ",predmisrms," actmisrms ",actmisrms

c   Find maximum change to model (well, to velocity
c   parameters anyway) to test for convergence 
        chmax = 0.0
        do ii = 1,nnodes
          ip = i6 + ii
          chmax = dmax1(chmax, dabs(change(ip)))
        enddo
        write(*,*) icnt, chmax
        icnt = icnt +1
c  calculate misfit after inversion
c  *******************************************
c  test for convergence and finish iteration
c  ********************************************
        if ((chmax.gt.0.0005).and.(icnt.le.iterlimit)) go to 100
        write(*,*) icnt
c  The first time through, solutions are damped with data variance as an
c  estimate.  Go through again with a posteriori estimate of data variance
c  different for each event.
        if (iter.eq.1) then
           icnttot = icnt
           iter = 2
           minstd =.03
           naddat = 0
           do iev = 1, nevents
             sumsq = 0.0
             do ista = 1, 2*nsta(iev)
               sumsq = sumsq + d(ista+naddat)**2
             enddo
c  number of degrees of freedom based on amplitude misfit - only two
c  adjustable amplitude parameters per event
c             sigma2 = sumsq/(nsta(iev)-2)
c  number of degrees of freedom assuming 6 wave parameters per event and that
c  each event supplies average of about 2 pieces of information about the 
c  velocity structure
c             sigma2 = sumsq/(2*nsta(iev)-8)
c  rank2 is the rank for velocity. the for 2-D isotropy (n nodes)and uniform anisotropy 
c  the rank is not 2*n+2 because the velocity is not independent.do the if test in our case 
	     
	      if ((2*nsta(iev) - (rank2+rank3)/nevents - 6).lt.1.0) then
	      sigma2=sumsq/1.0
	      else
	      sigma2 = sumsq/(2*nsta(iev) - (rank2+rank3)/nevents - 6)
	      endif
             
	      
             stddevdata(iev) = stddevdata(iev)*sqrt(sigma2)
c  set floor on how small stddevdata is allowed to get - below .03 probably
c  unrealistic even for best data
             if (stddevdata(iev).lt.minstd) stddevdata(iev)=minstd
             naddat = naddat + 2*nsta(iev)
           enddo
           icnt = 1
           go to 100
         endif

c  By the time this converges to a solution, d should contain the normalized 
c  misfits
c  Calculate sigma**2 and standard deviation of model parameters
c  Problem with this again with too many parameters - calculate rms instead
c  or use sigma**2 = 1
        sumsq = 0.0
        naddat = 0
        totsumsqph  = 0.0
	totsumsqamp = 0.0
        do iev = 1, nevents
          write(10,*) 'event ', idnum(iev)
          sumsqph  = 0.0
	  sumsqamp =  0.
	  sumsqtemp = 0.0
          do ista = 1,nsta(iev)
            dresid1=d(ista+naddat)*stddevdata(iev)
            dresid2=d(ista+naddat+nsta(iev))*stddevdata(iev)
c  convert misfits back to original amplitude and phase
            predamp = amprms(iev,ifreq)
     1        *sqrt((streal(iev,ista,ifreq)-dresid1)**2 
     2                + (stimag(iev,ista,ifreq)-dresid2)**2)
            prefase = atan2(-(stimag(iev,ista,ifreq)-dresid2),
     1                (streal(iev,ista,ifreq)-dresid1))/twopi
c check for prefase being off by twopi
           absmis = abs(prefase - dph(iev,ista))
	   phasemis = absmis - int(absmis)	   
           if (phasemis.gt.0.5) phasemis = phasemis-1.0
           write(10,*) ista, streal(iev,ista,ifreq),dresid1,
     1                    stimag(iev,ista,ifreq), dresid2,
     2         staamp(iev,ista,ifreq), predamp, dph(iev,ista), prefase

           sumsq = sumsq+(d(ista+naddat)**2+d(ista+naddat+nsta(iev))**2)
     1               *stddevdata(iev)**2
           sumsqtemp = sumsqtemp+(d(ista+naddat)**2+
     1                 d(ista+naddat+nsta(iev))**2)
     1               *stddevdata(iev)**2

           sumsqph = sumsqph + phasemis**2
	   sumsqamp = sumsqamp + ((predamp-staamp(iev,ista,ifreq))
     1                           /amprms(iev,ifreq))**2

          enddo
          totsumsqph = totsumsqph + sumsqph/freq(ifreq)**2
	  totsumsqamp = totsumsqamp + sumsqamp
          rmsphase(iev) = sqrt(sumsqph/nsta(iev))/freq(ifreq)
	  rmsamp(iev)   = sqrt(sumsqamp/nsta(iev))
	  rmsdata(iev) = sqrt(sumsqtemp/(2*nsta(iev)))
          naddat = naddat + 2*nsta(iev)
        enddo
c  rmsph multiplied by 2 because only half the number of observations
        rmsph = sqrt(2.*totsumsqph/nobs)
	rmsamplitude = sqrt(2.*totsumsqamp/nobs)
        sigma2 = sqrt(sumsq/nobs)
c        do j = 1, npsub
c          stddev(j+i6) = sqrt(subgtginv(j,j))
        do j = 1, np
          stddev(j) = sqrt(gtginv(j,j))
        enddo
        write(10,*) 'nobs',nobs, 'rank', rank, ' 
     1      rank from isovel params ', rank2
        write(10,*) 'rank from anisovel params ', rank4
        write(10,*) ' rank from station corrections, etc.', rank3
        write(10,*) icnttot, icnttot2,icnt, ' iterations', sigma2, 
     1     ' unnormalized rms misfit', rmsph, 'rms phase misfit,  s',
     1        '  rms amp mistfit   ', rmsamplitude

        write(11,*) 'nobs',nobs, 'rank', rank, 
     1      ' rank from isovel params ', rank2
        write(11,*) 'rank from anisovel params ', rank4
        write(11,*) ' rank from station corrections, etc.', rank3
        write(11,*) icnttot, icnttot2,icnt, ' iterations', sigma2, 
     1     ' unnormalized rms misfit', rmsph, 'rms phase misfit,  s',
     1        '  rms amp mistfit   ', rmsamplitude

c find median event rms phase misfit
        imed1 = (nevents+1)/2
        imed2 = (nevents+2)/2
        do iev = 1, nevents
           sortrms(iev) = rmsphase(iev)
        enddo
        call shell(nevents, sortrms)
        rmsmedian = (sortrms(imed1)+sortrms(imed2))/2.0
        write(10,*) 'median event misfit', rmsmedian
        write(11,*) 'median event misfit', rmsmedian
        do iev = 1, nevents
          ip = (iev-1)*6
          write(10,*) 'event ', idnum(iev), rmsdata(iev), 
     1  ' data std dev', rmsphase(iev), 'rms phase misfit  s',
     1  '  rms amp mistfit   ',  rmsamp(iev)
          write(11,*) 'event ', idnum(iev), rmsdata(iev), 
     1  ' data std dev', rmsphase(iev), 'rms phase misfit  s',
     1  '  rms amp mistfit   ',  rmsamp(iev)

          wvaz1= stazim1(iev)/convdeg
          wvaz2 = stazim2(iev)/convdeg
          stdwvaz1 = stddev(ip+3)/convdeg
          stdwvaz2 = stddev(ip+4)/convdeg
          write(10,*) wvaz1, startamp1(iev), stphase1(iev)
          write(10,*) wvaz2,startamp2(iev), stphase2(iev)
          write(11,*) wvaz1, startamp1(iev), stphase1(iev)
          write(11,*) wvaz2,startamp2(iev), stphase2(iev)
        enddo

c   write parameter covariance matrix for isotropic velocity parameters
c   for use in calculating variance of velocity model.  Could be smart and
c   write only upper or lower triangle of symmetric matrix to save space.

        write(16,*) nnodes
	do ii = 1, nnodes
          do jj = 1, nnodes
c	    write(16,*) subgtginv(ii,jj)
	    write(16,*) gtginv(ii+i6,jj+i6)
	    covar(ii,jj) = gtginv(ii+i6,jj+i6)
          enddo
        enddo
        do ii = 1, nnodes
          write(10,*) ii, crrntmod(ii+i6), stddev(ii+i6),residdiag(ii),
     1          nodelon(ii),nodelat(ii)
          write(11,*) ii, crrntmod(ii+i6), stddev(ii+i6),residdiag(ii),
     1          nodelon(ii),nodelat(ii)
c  JBR - begin edit
          write(22,*) ii, crrntmod(ii+i6), stddev(ii+i6),residdiag(ii),
     1          nodelon(ii),nodelat(ii)
c  JBR - end edit
	  vchange(ii) = crrntmod(ii+i6) - nodevel(ii)
c          write(30,*) ii,nodelon(ii),nodelat(ii), 
c     1              crrntmod(ii+i6),stddev(ii+i6),vchange(ii)
        enddo
        write(30,*) nnodes
        do ii = 1, iarea
           iii= i6 + nnodes +ii
           iiii = iii+iarea
           write(10,*) crrntmod(iii),stddev(iii), crrntmod(iiii),
     1                   stddev(iiii), nodelon(ii),nodelat(ii)
           write(11,*) crrntmod(iii),stddev(iii), crrntmod(iiii),
     1                   stddev(iiii), nodelon(ii),nodelat(ii)
c  JBR - begin edit
           write(23,*) crrntmod(iii),stddev(iii), crrntmod(iiii),
     1                   stddev(iiii), nodelon(ii),nodelat(ii)
c  JBR - end edit
           write(30,1276) nodelon(ii),nodelat(ii), 
     1        crrntmod(iii),stddev(iii), crrntmod(iiii),stddev(iiii)
	enddo
1276    format(f9.3,f8.3,4(f8.4))
        jcnt = 0
        do ii = 1,mxnsta
          if (nevntsta(ii).gt.0) then
            jcnt = jcnt +1
            ip = jcnt + npnoamp
            write(10,*) ii, ampmult(jcnt), stddev(ip),' ', staname(ii)
            write(11,*) ii, ampmult(jcnt), stddev(ip),' ', staname(ii)
C     JBR - begin edit
            write(24,*) ii, ampmult(jcnt), stddev(ip),' ', staname(ii)
c     JBR - end edit
          endif
        enddo
	if (ntyp1.ne.0) then
 	write (10,*) 'station phase corrections'
 	write (11,*) 'station phase corrections'
         do ii=1, ntyp1                                                      
           ip=npp+ii                                                         
           write(10,*) ii, ityp1sta(ii),phcor(ii), stddev(ip)                
           write(11,*) ii, ityp1sta(ii),phcor(ii), stddev(ip)                
        enddo
	endif                                                                
	write(10,*) 'attenuation correction'
	write(11,*) 'attenuation correction'
        write(10,*) gamma, stddev(np)  
        write(11,*) gamma, stddev(np)
c  JBR - begin edit
        write(25,*) gamma, stddev(np)
c  JBR - end edit

	do ii = 1, nnodes
c	  write(20,*) nodelon(ii),nodelat(ii), residrow(ii)
	  write(21,*) nodelon(ii),nodelat(ii),residdiag(ii)
	enddo
c  change predicted phase velocities from a priori model to new results on
c  same grid as a priori model
        
	call updateapri(fendvel,unifvel,preunifvel,dampvel,nnodes)
	
      enddo
c  end loop over frequencies, which is silly since nfreq should always = 1

900   close(unit = 10)
      close(unit = 11)
      close(unit = 12)
      close(unit = 13)
      close(unit = 14)
      close(unit = 15)
      close(unit = 16) 
      close(unit = 18)
      close(unit = 21)
      close(unit = 30) 
      close(unit = 66)    
C  JBR - begin edit
      close(unit = 22)    
      close(unit = 23)    
      close(unit = 24)   
      close(unit = 25)    
C  JBR - end edit  
      stop 
      end


      SUBROUTINE dlubksb(a,n,np,indx,b)
      INTEGER n,np,indx(n)
      DOUBLE PRECISION a(np,np),b(n)
      INTEGER i,ii,j,ll
      DOUBLE PRECISION sum
      ii=0
      do 12 i=1,n
        ll=indx(i)
        sum=b(ll)
        b(ll)=b(i)
        if (ii.ne.0)then
          do 11 j=ii,i-1
            sum=sum-a(i,j)*b(j)
11        continue
        else if (sum.ne.0.) then
          ii=i
        endif
        b(i)=sum
12    continue
      do 14 i=n,1,-1
        sum=b(i)
        do 13 j=i+1,n
          sum=sum-a(i,j)*b(j)
13      continue
        b(i)=sum/a(i,i)
14    continue
      return
      END


      SUBROUTINE dludcmp(a,n,np,indx,d)
      INTEGER n,np,indx(n),NMAX
      double precision d,a(np,np),TINY
      PARAMETER (NMAX=4000,TINY=1.0e-20)
      INTEGER i,imax,j,k
      double precision aamax,dum,sum,vv(NMAX)
      d=1.
      do 12 i=1,n
        aamax=0.
        do 11 j=1,n
          if (abs(a(i,j)).gt.aamax) aamax=abs(a(i,j))
11      continue
        if (aamax.eq.0.) write(*,*) 'singular matrix in ludcmp'
        vv(i)=1./aamax
12    continue
      do 19 j=1,n
        do 14 i=1,j-1
          sum=a(i,j)
          do 13 k=1,i-1
            sum=sum-a(i,k)*a(k,j)
13        continue
          a(i,j)=sum
14      continue
        aamax=0.
        do 16 i=j,n
          sum=a(i,j)
          do 15 k=1,j-1
            sum=sum-a(i,k)*a(k,j)
15        continue
          a(i,j)=sum
          dum=vv(i)*abs(sum)
          if (dum.ge.aamax) then
            imax=i
            aamax=dum
          endif
16      continue
        if (j.ne.imax)then
          do 17 k=1,n
            dum=a(imax,k)
            a(imax,k)=a(j,k)
            a(j,k)=dum
17        continue
          d=-d
          vv(imax)=vv(j)
        endif
        indx(j)=imax
        if(a(j,j).eq.0.)a(j,j)=TINY
        if(j.ne.n)then
          dum=1./a(j,j)
          do 18 i=j+1,n
            a(i,j)=a(i,j)*dum
18        continue
        endif
19    continue
      return
      END

      subroutine disthead(slat,slon,flat,flon,delta,azim)
c  Calculates distance and azimuth on sphere from starting point s 
c  to finishing point f
      dtor= 3.1415928/180.
      slt = slat*dtor
      sln = slon*dtor
      flt = flat*dtor
      fln = flon*dtor
      delta = acos(sin(slt)*sin(flt)+cos(slt)*cos(flt)*cos(fln-sln))
      azim = atan2(sin(fln-sln)*cos(flt),
     1  sin(flt)*cos(slt) - cos(fln-sln)*cos(flt)*sin(slt))
      delta = delta/dtor
      azim = azim/dtor
      return
      end

      subroutine gohead(slat,slon,delta,azim,flat,flon)
c Calculates final latitude and longitude f when starting at point s
c traveling delta degrees on sphere at initial heading azim
      dtor= 3.1415928/180.
      slt = slat*dtor
      dlta = delta*dtor
      azm = azim*dtor
      flat = asin(cos(slt)*sin(dlta)*cos(azm) + sin(slt)*cos(dlta))
      flon = atan2(sin(dlta)*sin(azm), 
     1   cos(slt)*cos(dlta) - sin(slt)*sin(dlta)*cos(azm))
      flat = flat/dtor
      flon = slon + flon/dtor
      if (flon.gt.360.) flon = flon - 360.
      if (flon.lt.-360.) flon = flon + 360.
      return
      end	

      subroutine shell(n,a)
c  shell sort from Press et al.  Sorts a, replacing original, in ascending order
      integer n, i,j, inc
      real a(n), v
      inc = 1
1     inc = 3*inc + 1
      if (inc.le.n) go to 1
2       continue
        inc = inc/3
        do i = inc+1, n
          v = a(i)
          j = i
3         if (a(j-inc).gt.v) then
            a(j) = a(j-inc)
            j = j-inc
            if (j.le.inc) go to 4
          go to 3
          endif
4         a(j) = v
        enddo
        if(inc.gt.1) go to 2
        return
        end

      subroutine search(pb)
c  uses grid search to find estimates of best fitting wave parameters for each event,
c  with fixed velocity structure
      parameter (maxnfreq=1, maxnsta=300, nparam = 4000,
     1           maxnobs = 25000, maxnodes = 2000, maxevnts = 400,
     1           maxnxints = 401, maxnyints = 401,ndeg = 81 )

      real*4 streal(maxevnts,maxnsta,maxnfreq)
      real*4 stimag(maxevnts,maxnsta,maxnfreq)
      real*4 rloc(maxevnts,maxnsta), azloc(maxevnts,maxnsta)
      real*4 d(maxnobs), xsta(maxevnts,maxnsta),ysta(maxevnts,maxnsta)
      real*4 freq(maxnfreq)
      real*4 stddevdata(maxevnts)
      real*4 dtime(maxnsta), avslow(maxnsta)
      real*4 xbegkern,dxkern
      real*4 xbox(maxevnts,4),ybox(maxevnts,4)
      real*4 wgtnode1(maxnsta,maxnodes,ndeg)
      real*4 ampwgtnode1(maxnsta,maxnodes,ndeg)
      real*4 dxnode,dynode
      real*8 sensitivity(maxnxints,maxnyints)
      real*8 ampsens(maxnxints,maxnyints)
      real*4 damp1per(maxnsta), damp2per(maxnsta)
      real*4 dphase1(maxnsta),dphase2(maxnsta)
      real*4 phase1(maxnsta), phase2(maxnsta)
      real*4 ybegkern,dykern
      real*4 xnode(maxevnts,maxnodes),ynode(maxevnts,maxnodes)
      real*4 dtime1(maxnsta),dtime2(maxnsta),phcor(50)   
      real*4 phase(maxnsta,ndeg),dphase(maxnsta,ndeg),
     1       dampper(maxnsta,ndeg)
      real*4 appvel(maxnodes),ampmult(maxnsta)
      real*4 xmin(maxevnts,ndeg), unifvel
      real*4 gamp(maxnsta,2)
      real*4 pb(6)
      integer*4 nsta(maxevnts), iref(maxevnts)
      integer*4 istanum(maxevnts,maxnsta),istacor(maxnsta)
      integer*4   istavar(maxnsta)
      integer*4 nxkern,nykern, nnodes
      integer*4 ityp1sta(maxnsta),ntyp1 
                                                                                
       common /residua/ sensitivity,ampsens,d,rloc,azloc,freq,
     1 xsta,dtime,avslow,streal,stimag,stddevdata,phcor, 
     1 xbox,ybox,ysta,dxkern,dykern,dxnode,dynode,
     1 unifvel,appvel,ampmult,gamma,
     1 xnode, ynode,wgtnode1,ampwgtnode1,xmin,
     1 phase,dphase,dampper,istavar,istanum,nxkern,nykern,
     1 ityp1sta,ntyp1,iref,nsta,iev,naddat,ifreq,nnodes                 

        twopi = 3.1415928*2.
        onepi = 3.1415928
        convdeg = 3.1415928/180.
      azimlmn1 = -20.0*convdeg
      azimlmx1 = 20.01*convdeg
      azimint1 = 2.0*convdeg
c      azimint1 = 1.0*convdeg
      azimlmn2 = -40.0*convdeg
      azimlmx2 = 40.01*convdeg
      azimint2 = 4.0*convdeg
c      azimint2 = 2.0*convdeg
      phaselmn1 = -0.25
      phaselmx1 = 0.25
c      phaselmn1 = -0.5
c      phaselmx1 = 0.5
      phaseint1 = 0.01
c      phaseint1 = 0.02

      phaselmn2 = -0.25
      phaselmx2 = 0.25
c      phaselmn2 = -0.5
c      phaselmx2 = 0.5
      phaseint2 = 0.01
c      phaseint2 = 0.02
      iter = 0
      bmisfit = 1.0E+30
      funiv = freq(1)/unifvel
100   iter = iter + 1
      nsrhazim1 = (azimlmx1-azimlmn1)/azimint1 + 1
      do isrhazim1 = 1, nsrhazim1
c JBR - begin edit
c        srhazim1 = azimlmn1 + (isrhazim1-1)*azimint1
        srhazim1 = 0
c JBR - end edit
c      do srhazim1 = azimlmn1, azimlmx1,azimint1
        cs1 = cos(srhazim1)
	sn1 = sin(srhazim1)
	ideg1 = int(srhazim1/convdeg+(ndeg-1)/2 +0.01) + 1
        nsrhazim2 = (azimlmx2-azimlmn2)/azimint2 + 1
        do isrhazim2 = 1, nsrhazim2
          srhazim2 = azimlmn2 + (isrhazim2-1)*azimint2
c        do srhazim2 = azimlmn2,azimlmx2,azimint2
	  if (abs(srhazim2-srhazim1).gt.0.001) then
	  cs2 = cos(srhazim2)
	  sn2 = sin(srhazim2)
          ideg2 = int(srhazim2/convdeg+(ndeg-1)/2 + 0.01) + 1
c	  write(*,*) ideg1,srhazim1/convdeg,ideg2,srhazim2/convdeg
	  nsrhphase1 = (phaselmx1-phaselmn1)/phaseint1 + 1
	  do isrhphase1 = 1,nsrhphase1
  	   srhphase1 = phaselmn1 + (isrhphase1-1)*phaseint1  
c	  do srhphase1 = phaselmn1,phaselmx1,phaseint1
 	   nsrhphase2 = (phaselmx2-phaselmn2)/phaseint2 + 1
	   do isrhphase2 = 1,nsrhphase2
  	    srhphase2 = phaselmn2 + (isrhphase2-1)*phaseint2  
c	    do srhphase2 = phaselmn2,phaselmx2,phaseint2
	      do 10 ista = 1, nsta(iev)
       		xstatemp = xsta(iev,ista)*cs1 + ysta(iev,ista)*sn1
c		ystatemp = xsta(iev,ista)*sn1 + ysta(iev,ista)*cs1
  		phase1(ista) = (xstatemp-xmin(iev,ideg1))*funiv
		xstatemp = xsta(iev,ista)*cs2 + ysta(iev,ista)*sn2
c		ystatemp = xsta(iev,ista)*sn2 + ysta(iev,ista)*cs2
  		phase2(ista) = (xstatemp-xmin(iev,ideg2))*funiv
c  calculate effects of uniform velocity
  10 	      enddo
  	      gtg11 = 0.0
	      gtg12 = 0.0
	      gtg22 = 0.0
	      gtd1 = 0.0
	      gtd2 = 0.0
	      do ista = 1,nsta(iev)
                prefase1 = ( (phase1(ista)+dphase(ista,ideg1))
     1   	- (phase1(iref(iev))+dphase(iref(iev),ideg1)))
     1             + srhphase1
        	prefase2 = ( (phase2(ista)+dphase(ista,ideg2))
     1   	- (phase2(iref(iev))+dphase(iref(iev),ideg2)))
     1             + srhphase2
		if (ntyp1.ne.0) then
        	do itypst=1, ntyp1                                   
         	  if (istanum(iev,ista).eq.ityp1sta(itypst)) then     
          	  prefase1=prefase1+phcor(itypst)                    
          	  prefase2=prefase2+phcor(itypst)                    
	 	  endif                                               
        	enddo 
		endif
		
		ampfac  = ampmult(istavar(istanum(iev,ista)))
     1			*exp(-gamma*xsta(iev,ista))                                              
		ampfac1 = (1.+dampper(ista,ideg1))*ampfac
		ampfac2 = (1.+dampper(ista,ideg2))*ampfac
c  now do linear inversion for best amplitudes given these trial azimuths and phases
c  This is a completely linear inversion at this point, so can use zero starting model
c  for amplitudes, and for 2x2 inversion of symmetric GTG matrix can use analytical inverse.
		
c  data vector and partial derivatives listed event by event with all
c  real data for first event followed by imaginary data

               	cosph1 = cos(prefase1*twopi)
          	cosph2 = cos(prefase2*twopi)
          	sinph1 = sin(prefase1*twopi)
          	sinph2 = sin(prefase2*twopi)
          	gamp(ista,1) = ampfac1*cosph1/stddevdata(iev)
		gamp(ista,2) = ampfac2*cosph2/stddevdata(iev)
		gamp(ista+nsta(iev),1)=-ampfac1*sinph1/stddevdata(iev)
		gamp(ista+nsta(iev),2)=-ampfac2*sinph2/stddevdata(iev)
		gtg11 = gtg11+gamp(ista,1)**2+gamp(ista+nsta(iev),1)**2
		gtg22 = gtg11+gamp(ista,2)**2+gamp(ista+nsta(iev),2)**2
		gtg12 = gtg12+gamp(ista,1)*gamp(ista,2)
     1		        + gamp(ista+nsta(iev),1)*gamp(ista+nsta(iev),2)
		gtd1 = gtd1 + (gamp(ista,1)*streal(iev,ista,ifreq)
     1		  +gamp(ista+nsta(iev),1)*stimag(iev,ista,ifreq))
     2             /stddevdata(iev)
		gtd2 = gtd2 + (gamp(ista,2)*streal(iev,ista,ifreq)
     1		  +gamp(ista+nsta(iev),2)*stimag(iev,ista,ifreq))
     2             /stddevdata(iev)
	      enddo
	      c2ab = gtg12*gtg12-gtg11*gtg22
	      gtginv11 = -gtg22/c2ab
	      gtginv22 = -gtg11/c2ab
	      gtginv12 = gtg12/c2ab
c   stampmod1 and stampmod2 should be best estimates of amps for these angles and phases
	      stampmod1 = gtginv11*gtd1 + gtginv12*gtd2
c JBR - begin edit
c	      stampmod2 = gtginv12*gtd1 + gtginv22*gtd2
          stampmod2 = 0
c JBR - end edit

c  now calculate residuals to starting model 
	      pmisfit = 0.0
	      do ista = 1,nsta(iev) 
	        pmisfit = pmisfit+(gamp(ista,1)*stampmod1
     1		  +gamp(ista,2)*stampmod2 
     2		  - streal(iev,ista,ifreq)/stddevdata(iev))**2
	        pmisfit = pmisfit + (gamp(ista+nsta(iev),1)*stampmod1
     1		  + gamp(ista+nsta(iev),2)*stampmod2 
     2            - stimag(iev,ista,ifreq)/stddevdata(iev))**2
     	      enddo
	      if (pmisfit.lt.bmisfit) then
	        bmisfit = pmisfit
	        pb(1) = stampmod1
	        pb(2) = stampmod2
	        pb(3) = srhazim1
	        pb(4) = srhazim2
	        pb(5) = srhphase1
	        pb(6) = srhphase2
	      endif
	    enddo
	  enddo
	  endif
	enddo
      enddo
c now refine search in vicinity of best model from coarse search
      if (iter.eq.1) then
        azimlmn1 = pb(3)-2.0*convdeg
        azimlmx1 = pb(3)+2.0*convdeg
        azimint1 = 1.0*convdeg
        azimlmn2 = pb(4)-4.0*convdeg
	if (azimlmn2.lt.-40.*convdeg) azimlmn2 = -40.*convdeg
        azimlmx2 = pb(4)+4.0*convdeg
	if (azimlmx2.gt.40.*convdeg) azimlmx2 = 40.*convdeg
        azimint2 = 2.0*convdeg
c        phaselmn1 = pb(5)-0.01
c        phaselmx1 = pb(5)+0.01
        phaselmn1 = pb(5)-0.02
        phaselmx1 = pb(5)+0.02
        phaseint1 = 0.0025
c        phaselmn2 = pb(6)-0.01
c        phaselmx2 = pb(6)+0.01
        phaselmn2 = pb(6)-0.02
        phaselmx2 = pb(6)+0.02
        phaseint2 = 0.0025
	go to 100
      endif
c      write(*,*) iev,pmisfit,pb(1),pb(2),pb(3),pb(4),pb(5),pb(6)
c      write(*,*) iev,bmisfit,pb(1),pb(2),pb(3),pb(4),pb(5),pb(6)
      return
      end

      subroutine actlmsft(actmisrms)
       parameter (maxnfreq=1, maxnsta=300, nparam = 4000,
     1           maxnobs = 25000, maxnodes = 2000, maxevnts = 400,
     1           maxnxints = 401, maxnyints = 401,ndeg = 81 )

      real*4 streal(maxevnts,maxnsta,maxnfreq)
      real*4 stimag(maxevnts,maxnsta,maxnfreq)
      real*4 rloc(maxevnts,maxnsta), azloc(maxevnts,maxnsta)
      real*4 d(maxnobs), xsta(maxevnts,maxnsta),ysta(maxevnts,maxnsta)
      real*4 freq(maxnfreq)
      real*4 stddevdata(maxevnts)
      real*4 dtime(maxnsta), avslow(maxnsta)
      real*4 xbegkern,dxkern
      real*4 xbox(maxevnts,4),ybox(maxevnts,4)
      real*4 wgtnode1(maxnsta,maxnodes,ndeg)
      real*4 ampwgtnode1(maxnsta,maxnodes,ndeg)
      real*4 dxnode,dynode
      real*8 sensitivity(maxnxints,maxnyints)
      real*8 ampsens(maxnxints,maxnyints)
      real*4 damp1per(maxnsta), damp2per(maxnsta)
      real*4 dphase1(maxnsta),dphase2(maxnsta)
      real*4 phase1(maxnsta), phase2(maxnsta)
      real*4 ybegkern,dykern
      real*4 xnode(maxevnts,maxnodes),ynode(maxevnts,maxnodes)
      real*4 dtime1(maxnsta),dtime2(maxnsta),phcor(50)   
      real*4 phase(maxnsta,ndeg),dphase(maxnsta,ndeg),
     1       dampper(maxnsta,ndeg)
      real*4 appvel(maxnodes),ampmult(maxnsta)
      real*4 xmin(maxevnts,ndeg), unifvel
      real*4 bazi(maxevnts,maxnsta)
      real*4 cos2node(maxnodes,ndeg),sin2node(maxnodes,ndeg)
      real*4 crrntmod(nparam)      
      real*4 gamp(maxnsta,2)
      real*4 pb(6)
      real*4 startamp1(maxevnts),startamp2(maxevnts)
      real*4 stphase1(maxevnts),stphase2(maxevnts)
      real*4 stazim1(maxevnts),stazim2(maxevnts)

      integer*4 nsta(maxevnts), iref(maxevnts)
      integer*4 istanum(maxevnts,maxnsta),istacor(maxnsta)
      integer*4 idnode(maxnodes)
      integer*4   istavar(maxnsta)
      integer*4 nxkern,nykern, nnodes
      integer*4 ityp1sta(maxnsta),ntyp1 
      integer*4 nevents
                                                                                
       common /residua/ sensitivity,ampsens,d,rloc,azloc,freq,
     1 xsta,dtime,avslow,streal,stimag,stddevdata,phcor, 
     1 xbox,ybox,ysta,dxkern,dykern,dxnode,dynode,
     1 unifvel,appvel,ampmult,gamma,
     1 xnode, ynode,wgtnode1,ampwgtnode1,xmin,
     1 phase,dphase,dampper,istavar,istanum,nxkern,nykern,
     1 ityp1sta,ntyp1,iref,nsta,iev,naddat,ifreq,nnodes                 

       common /msft/ bazi,cos2node,sin2node,crrntmod,
     1   startamp1,startamp2,stphase1,stphase2,stazim1,stazim2,
     2   nevents,idnode,ideg1,ideg2,nobs,i6,iarea

        twopi = 3.1415928*2.
        onepi = 3.1415928
        convdeg = 3.1415928/180.
	actmisfit = 0.0
       do iev = 1, nevents
c   calculate the sensitivity kernel for fixed angles

        do 125 idegg = 1,2
	  if (idegg.eq.1) ideg = ideg1
	  if (idegg.eq.2) ideg = ideg2
          azimt = ((ideg-1.) - (ndeg-1.)/2.)*convdeg
          cs2n = cos(2.0*(convdeg*bazi(iev,iref(iev))- azimt))
	  sn2n = sin(2.0*(convdeg*bazi(iev,iref(iev))- azimt))
	  cs1z = cos(azimt)
	  sn1z = sin(azimt)

          do ii = 1,nnodes
c don't really need arrays here in this version, but used throughout so retained
            cos2node(ii,ideg)=cs2n
            sin2node(ii,ideg)=sn2n
          enddo

c  calculate current apparent velocity at each node

        do ii = 1, nnodes
          iii  = ii+i6
          jjj  = i6+nnodes + idnode(ii)
	  jjjj = jjj + iarea
          appvel(ii) =       crrntmod(iii)
     1   + cos2node(ii,ideg)*crrntmod(jjj)
     1   + sin2node(ii,ideg)*crrntmod(jjjj)
c       write(14,*) iev,ideg,ii, appvel(ii)
        enddo

c  loop over stations, generating sensitivity kernels for each
        do 102 ista = 1, nsta(iev)

          do ii = 1, nnodes
	      wgtnode1(ista,ii,ideg) = 0.0
	    ampwgtnode1(ista,ii,ideg) = 0.0
          enddo

          xstatemp = 
     1      xsta(iev,ista)*cs1z
     1      + ysta(iev,ista)*sn1z               
     
          ystatemp = 
     1      -xsta(iev,ista)*sn1z
     1      + ysta(iev,ista)*cs1z     

          do ii = 1,nnodes

           xnodetemp = 
     1      xnode(iev,ii)*cs1z
     1      + ynode(iev,ii)*sn1z               
     
           ynodetemp = 
     1      -xnode(iev,ii)*sn1z
     1      + ynode(iev,ii)*cs1z     


           xstanode = xnodetemp - xstatemp
	   ystanode = ynodetemp - ystatemp

c  find nearest point in sensitivity kernel - kernels should have been
c  calculated with smoothing so that they represent sensitivity to nodal
c  coefficient rather than velocity at point  - could interpolate, but 
c this is sufficiently accurate if kernels on fine enough scale (i.e.,
c  dxkern << smoothing length
         if (xnodetemp.ge.xmin(iev,ideg)) then
          if (xstanode.ge.0.0) then
            ixindex = int( xstanode/dxkern +0.5) + (nxkern+1)/2
	  else
	    ixindex = int( xstanode/dxkern -0.5) + (nxkern+1)/2
	  endif
          if (ystanode.ge.0.0) then
            iyindex = int( ystanode/dykern +0.5) + (nykern+1)/2
	  else
	    iyindex = int( ystanode/dykern -0.5) + (nykern+1)/2
	  endif

          if(  ixindex .lt.1 .or. ixindex .gt. nxkern
     1    .or. iyindex .lt.1 .or. iyindex .gt. nxkern) then 


C	    write(*,*) 'ixindex,iyindex,iev,ista,ideg', 
C     1            ixindex,iyindex,iev,ista,ideg
	     wgtnode1(ista,ii,ideg)    = 0.
	     ampwgtnode1(ista,ii,ideg) = 0.  

 	   else

             wgtnode1(ista,ii,ideg) = sensitivity(ixindex,iyindex)
             ampwgtnode1(ista,ii,ideg) =     ampsens(ixindex,iyindex)
           endif 
	  else 
	     wgtnode1(ista,ii,ideg)    = 0.
	     ampwgtnode1(ista,ii,ideg) = 0.  
           endif	   
          enddo

	 dphase(ista,ideg) = 0.
         dampper(ista,ideg) = 0.
c  corrections for second order effects of large velocity changes in version 587
c   old version commented out
          do inode = 1, nnodes
c          dphase(ista,ideg) = dphase(ista,ideg) 
c     1  + (1.0/twopi)*wgtnode1(ista,inode,ideg)
c     1           *(appvel(inode)-unifvel)/unifvel
          dphase(ista,ideg) = dphase(ista,ideg) 
     1  + (1.0/twopi)*wgtnode1(ista,inode,ideg)
     2           *(appvel(inode)-unifvel)/appvel(inode)
     3           /(appvel(inode)/unifvel)

          enddo


	  do inode =1, nnodes
          dampper(ista,ideg) = dampper(ista,ideg) 
     1  +ampwgtnode1(ista,inode,ideg)*
c     1   (appvel(inode)-unifvel)/unifvel
     2    (appvel(inode)-unifvel)/appvel(inode)
     3           /(appvel(inode)/unifvel)

          enddo

c  end loop over stations
 102 	  enddo
c  end loop over angles
 125     enddo

c  calculate effect of uniform velocity for first plane wave
       do 10 ista = 1, nsta(iev)
       xstatemp = 
     1   xsta(iev,ista)*cos(stazim1(iev))
     1 + ysta(iev,ista)*sin(stazim1(iev))               
     
   	dtime1(ista) = (xstatemp-xmin(iev,ideg1))/unifvel

  10 	  enddo

c       calculate for second plane wave
  
        do 20 ista = 1, nsta(iev)
         
       xstatemp = 
     1   xsta(iev,ista)*cos(stazim2(iev))
     1 + ysta(iev,ista)*sin(stazim2(iev))               
     
   	dtime2(ista) = (xstatemp-xmin(iev,ideg2))/unifvel

	   phase1(ista) = dtime1(ista)*freq(1)
	   phase2(ista) = dtime2(ista)*freq(1)
	  dphase1(ista) =   dphase(ista,ideg1)
	  dphase2(ista) =   dphase(ista,ideg2)  
          damp1per(ista) = dampper(ista,ideg1)
	  damp2per(ista) = dampper(ista,ideg2) 

  20    enddo
   
c  convert time to phase and assign effects of lateral heterogeneities

        do ista = 1, nsta(iev)


        prefase1 = ( (phase1(ista)+dphase1(ista))
     1  - (phase1(iref(iev))+dphase1(iref(iev))))
     1             + stphase1(iev)
        prefase2 = ( (phase2(ista)+dphase2(ista))
     1  - (phase2(iref(iev))+dphase2(iref(iev))))
     1             + stphase2(iev)

	  staamp1 = startamp1(iev)*(1.+damp1per(ista))
	  staamp2 = startamp2(iev)*(1.+damp2per(ista))

c        parph1cor1=0.                                        
c        parph2cor1=0.                                        
	 
c         itypst2=0 
	if (ntyp1.ne.0) then
        do itypst=1, ntyp1                                    
         if (istanum(iev,ista).eq.ityp1sta(itypst)) then     
          prefase1=prefase1+phcor(itypst)                    
          prefase2=prefase2+phcor(itypst)                    
c          parph1cor1=1.                                      
c          parph2cor1=1.                                      
c	  itypst2=itypst                                     
	 endif                                               
        enddo
	endif                                                


          cosph1 = cos(prefase1*twopi)
          cosph2 = cos(prefase2*twopi)
          sinph1 = sin(prefase1*twopi)
          sinph2 = sin(prefase2*twopi)
          
          prereal = staamp1*cosph1+staamp2*cosph2
c	  write(*,*) prereal  
	  preimag = -1.0*(staamp1*sinph1+ staamp2*sinph2)
c           write(*,*) ampmult(istavar(istanum(iev,ista)))
          prereal = prereal*ampmult(istavar(istanum(iev,ista)))
     1          *exp(-gamma*xsta(iev,ista))
c          write(*,*) prereal
          preimag = preimag*ampmult(istavar(istanum(iev,ista)))
     1              *exp(-gamma*xsta(iev,ista))




c  data vector and partial derivatives listed event by event with all
c  real data for first event followed by imaginary data, then onto next event
c  d contains misfit to starting model


c          kreal = ista + naddat
c          kimag = kreal + nsta(iev)
          dkreal = (streal(iev,ista,ifreq) - prereal)/stddevdata(iev)
          dkimag = (stimag(iev,ista,ifreq) - preimag)/stddevdata(iev)
	  write(14,*) iev,ista,streal(iev,ista,ifreq),
     1        stimag(iev,ista,ifreq),prereal,preimag
          actmisfit = actmisfit + dkreal*dkreal+dkimag*dkimag
         enddo
c	 write(*,*) iev, ' stddevdata ',stddevdata(iev),' actmisfit ', actmisfit 
        enddo
	actmisrms = sqrt(actmisfit/nobs)
c	write(*,*) 'nobs ', nobs, ' ifreq ', ifreq,' unifvel ',unifvel
	return
	end
	
	
	
      subroutine genreggrid(freggrid,ntot,nxpt,dx,dy)
***************************************************************************
*   Create regularly spaced grid points in an area with center point (slat,slon). *
*   In order to avoid distortion at high latitude, change coordinates so   *
*   center of area lies along the equator of coordinate system and there is 
*   compensation for curvature.                                           *
*************************************************************************** 
c  WARNING   checkout scheme by running separately first gridreg < brwestreginp.dat
       parameter (nxptmx=200, nyptmx=200)
       parameter (maxnodes = 2000)

       real*4 dazim(nxptmx),ddelt(nyptmx),glat(nxptmx,nyptmx)
       real*4 glon(nxptmx,nyptmx)
      real*4 boxlat(4), boxlon(4)
      real*4 nodelat(maxnodes),nodelon(maxnodes)
       character*90 freggrid
       common /gengrid/ nodelat,nodelon,boxlat,boxlon
       open(15, file = freggrid, status = 'unknown')
       radius = 6371.
       pi = 3.14158
       convdeg = 2.0*pi/360.
c   'Enter the center point (slat, slon):'
       read(15,*) slat,slon
       sdelta=90.
c      sazimz is azimuth from the center point that will tilt grid relative to North
       read(15,*) sazimz
c  delx is increment in degrees at equator - the true increment will vary with latitude from
c  equator of projection
       read(15,*) nxpt, delx,begx
c to follow our traditional convention of listing points from right to left and bottom to top.
c  the degree increment for distance from the pole, dely, should be negative and the
c  beginning point should be farthest in degrees from projection pole (assuming sazimz is
c  northwards), (e.g., begy = 6 (degrees south of center point) is 96 degrees from pole)
c  begx would be negative and increase with positive delx
       read(15,*) nypt,dely, begy
c read in corners for wave intercepts to pass along to main program
       do i = 1, 4
         read(15, *) boxlat(i), boxlon(i)	
       enddo
       degdist = 2.0*pi*radius/360.
       dx = delx*degdist
       dy = dely*degdist
       call gohead(slat,slon,sdelta,sazimz,plat,plon)
       call disthead(plat,plon,slat,slon,delta,azimz)
       ntot = nxpt*nypt
       do 150 j=1,nypt
         delyinc = (j-1)*dely +begy	 
         delt = delta + delyinc	 
         do 100 i=1,nxpt
	   azim = azimz + (begx + (i-1)*delx)/cos(convdeg*delyinc)
	   call gohead(plat,plon,delt,azim,glat(i,j),glon(i,j))
	   if (glon(i,j).gt.180.0) then
	     glon(i,j) = glon(i,j) - 360.0
	   endif
  100	 enddo
  150  enddo 
c  arrange points in standard order in single dimensioned arrays
       nodecnt = 0
       do i = 1, nxpt
         do j = 1, nypt
	   nodecnt = nodecnt + 1
           nodelat(nodecnt) = glat(i,j)
	   nodelon(nodecnt) = glon(i,j)
	 enddo
       enddo
       close(15)  
  200  format(f7.3,f10.3)
       return
       end  
       
       
      subroutine assignstrt(startvel,nodevel,preunifvel,ntot,
     1                           nxpt,dxnode,dynode)
      parameter (maxnodes = 2000, maxstart = 200)
      character*90 startvel
      real*4 boxlat(4), boxlon(4)
      real*4 nodelat(maxnodes),nodelon(maxnodes),nodevel(maxnodes)
      real*4 latmin,latmax,lonmin,lonmax
      real*4 prdlon(maxstart),prdlat(maxstart),prdv(maxstart,maxstart)
      common /gengrid/ nodelat,nodelon,boxlat,boxlon
      common /updatest/ prdlon,prdlat,prdv,dylat,dxlon,
     1    beglat,endlat,dlat,beglon,endlon,dlon,nlat,nlon
     
      pi = 3.1415928
      convdeg = 3.1415928/180.

      deg2km = 111.194
      open(60, file = startvel)
c  assigns start values for node parameters based on a priori predictions of
c  starting model, previously generated.  Important that a priori grid extend
c  at least as far as model grid and that it is nearly as closely or more closely
c  spaced than model grid. Uses linear weighting between nodes to generate average value for
c  starting values.  A priori grid does not have same spacing and is assumed to 
c  be regularly spaced on Mercator projection, increasing in both lon and lat
c  
      read(60,*) beglat,endlat,dlat,beglon,endlon,dlon
      read(60,*) preunifvel
      nlat = (endlat-beglat)/dlat +1.01
      nlon = (endlon-beglon)/dlon + 1.01
c  file of phase velocity predictions are assumed to run through longitudes first,
c  before incrementing in latitude
      do ilat = 1, nlat
        do ilon = 1, nlon
	  read(60,*) prdlon(ilon),prdlat(ilat),prdv(ilon,ilat)
	enddo
      enddo
c  convert spacing of model back to degrees
      dylat = dynode/deg2km
      dxlon = dxnode/deg2km
      do i = 1, ntot
        sclfac = cos(convdeg*nodelat(i))
	dxxlon = dxlon/sclfac
        latmin = nodelat(i) - dylat
	latmax = nodelat(i) + dylat
	lonmin = nodelon(i) - dxxlon
	lonmax = nodelon(i) + dxxlon
	minlat = (latmin - beglat)/dlat +1
	if (minlat.lt.1) minlat = 1
	maxlat = (latmax-beglat)/dlat +1
	if (maxlat.gt.nlat) maxlat = nlat
	minlon = (lonmin-beglon)/dlon +1
	if (minlon.lt.1) minlon = 1
	maxlon = (lonmax-beglon)/dlon + 1
	if (maxlon.gt.nlon) maxlon = nlon
	wgtsum = 0.0
	sumvel = 0.0
	if ((minlat.gt.nlat).or.(maxlat.lt.1).or.
     1             (minlon.gt.nlon).or.(maxlon.lt.1)) then
           write (*,*) 
     1   'PROBLEM. Node outside region of starting predictions '
	   write (*,*) i, nodelat(i),nodelon(i)
	endif
	do ii = minlon,maxlon
	  do jj = minlat,maxlat
	    wgt = (1.-abs(nodelat(i)-prdlat(jj))/dylat)
     1             *(1.-abs(nodelon(i)-prdlon(ii))/dxxlon)
            sumvel = sumvel + wgt*prdv(ii,jj)
	    wgtsum = wgtsum + wgt
	  enddo
	enddo
	nodevel(i) = sumvel/wgtsum
c	write(*,*) i, nodevel(i),nodelat(i),nodelon(i)
c	write(*,*) minlat,maxlat,minlon,maxlon
      enddo
      return
      end
 

      subroutine updateapri(fendvel,unifvel,preunifvel,dampvel,nnodes)
c  Take inversion solution of changes to starting model and add back through
c  linear interpolation to detailed, a priori starting model. Also, generate 
c  standard deviation of estimate
c
c  Slow process because nodes not on regular grid of lat&lon - have to search for
c  which nodes are within interpolation range for every point
      parameter (maxnodes = 2000, maxstart = 200)
      character*90 fendvel
      real*4 boxlat(4), boxlon(4)
      real*4 nodelat(maxnodes),nodelon(maxnodes),nodevel(maxnodes)
      real*4 wgt(maxnodes)
      real*4 latmin,latmax,lonmin,lonmax
      real*4 prdlon(maxstart),prdlat(maxstart),prdv(maxstart,maxstart)
      real*4 newvel(maxstart,maxstart),stddevap(maxstart,maxstart)
      real*4 covar(maxnodes,maxnodes),vchange(maxnodes)
      integer iwgt(maxnodes)
      common /gengrid/ nodelat,nodelon,boxlat,boxlon
      common /updatest/ prdlon,prdlat,prdv,dylat,dxlon,
     1    beglat,endlat,dlat,beglon,endlon,dlon,nlat,nlon
      common /update2/ covar,vchange
     
      pi = 3.1415928
      convdeg = 3.1415928/180.

      open (70, file = fendvel)
      write(70,*) beglat,endlat,dlat,beglon,endlon,dlon
      sumall = 0.0
      do jj = 1,nlat
c  to correct for points on mercator grid being closer together away from equator
        sclfac = cos(prdlat(jj)*convdeg)
        do ii = 1,nlon
	  wgtsum = 0.0
	  velsum = 0.0
	  sumstdev = 0.0
	  nwgt = 0
	  do kk = 1,nnodes
	    xsep = abs(prdlon(ii)-nodelon(kk))*sclfac
	    if ((xsep.le.dxlon).and.
     1          (abs(prdlat(jj)-nodelat(kk)).le.dylat))  then
              wgt(kk) = (1.- abs(prdlat(jj)-nodelat(kk))/dylat)
     1                       *(1.- xsep/dxlon)
              nwgt = nwgt+1
              iwgt(nwgt) = kk
              wgtsum = wgtsum + wgt(kk)
	      velsum = velsum + wgt(kk)*vchange(kk)
	      sumstdev = sumstdev + wgt(kk)*sqrt(covar(kk,kk))
	    endif
	  enddo
	  if (nwgt.gt.0) then
      	    newvel(ii,jj)=prdv(ii,jj)+unifvel-preunifvel +velsum/wgtsum
	    stddevap(ii,jj) = sumstdev/wgtsum
c  Estimate uncertainty using covariance matrix - but for this application
c  we don't want to use full covariance including off-diagonal terms, because that
c  effectively gives estimates appropriate to averages over larger regions involving
c  multiple nodes.  Instead, what is desired is an estimate of the uncertainty as if
c  a node had been located at the interpolation point (although points in between really are
c  known better because the random variations from multiple nodes will tend to average out)..  	    
c	    do i = 1,nwgt
c	      do j = 1,nwgt
c	        sumcov = wgt(iwgt(i))*wgt(iwgt(j))*covar(iwgt(i),iwgt(j))
c	      enddo
c	    enddo
c	    stddevap(ii,jj) = sqrt(sumcov)/wgtsum
	   else
	     newvel(ii,jj) = prdv(ii,jj)+unifvel-preunifvel
	     stddevap(ii,jj) = dampvel
	   endif
c	  write(*,*) ii,jj,nwgt,(iwgt(ij),ij=1,nwgt),prdlon(ii),prdlat(jj)
	  sumall = sumall + newvel(ii,jj)
	enddo
      enddo
      avgvel = sumall/(nlat*nlon)
      write(70,*) avgvel
      do jj = 1,nlat
        do ii = 1,nlon
	  write(70,*) prdlon(ii),prdlat(jj),newvel(ii,jj),stddevap(ii,jj)
	enddo
      enddo
      
      close (70)
      return
      end
